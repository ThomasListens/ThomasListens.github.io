<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thomas LeRoy Meier - Links</title>
    <style>
        * {
            margin: 0; padding: 0; box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            background: #000;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #fff;
            font-weight: normal;
        }
        .container {
            max-width: 400px;
            width: 100%;
            text-align: center;
            animation: fadeInUp 0.8s ease-out;
            z-index: 10;
            position: relative;
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px);}
            to   { opacity: 1; transform: translateY(0);}
        }
        .profile-section {
            margin-bottom: 40px;
        }
        .profile-image {
            width: 120px; height: 120px;
            border: 2px solid #333;
            margin: 0 auto 20px;
            background: #111;
            display: flex; align-items: center; justify-content: center;
            font-size: 48px;
            transition: transform 0.3s ease;
            background-image: url('https://via.placeholder.com/120x120/111111/333333?text=IMAGE');
            background-size: cover; background-position: center;
        }
        .profile-image:hover { transform: scale(1.05);}
        .profile-name {
            font-size: 28px; font-weight: normal;
            margin-bottom: 10px; letter-spacing: 1px;
            color: #fff; text-transform: none;
        }
        .profile-description {
            font-size: 14px; opacity: 0.8; margin-bottom: 30px;
            line-height: 1.4; color: #fff; letter-spacing: 0.5px;
        }
        .links-container {
            display: flex; flex-direction: column; gap: 8px;
            max-width: 320px; margin: 0 auto;
        }
        .link-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid #333;
            border-radius: 0px;
            padding: 16px 20px;
            text-decoration: none;
            color: #fff;
            display: flex; align-items: center;
            font-weight: normal; font-size: 17px; letter-spacing: 2.5px;
            transition: all 0.3s ease;
            position: relative; overflow: hidden;
            text-transform: uppercase; z-index: 2;
            min-height: 56px;
        }
        
        /* Subtle constellation particles within links */
        .link-constellation {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 1;
            opacity: 0.1;
        }
        
        .link-star {
            position: absolute;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
            border-radius: 50%;
            width: 1px; height: 1px;
            animation: starTwinkle 4s ease-in-out infinite;
            box-shadow: 0 0 2px rgba(255,255,255,0.4);
        }
        
        .link-connection {
            position: absolute;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%);
            height: 0.5px;
            transform-origin: left center;
            animation: connectionPulse 6s ease-in-out infinite;
        }
        
        @keyframes starTwinkle {
            0%, 100% { opacity: 0.1; transform: scale(0.5); }
            50% { opacity: 0.4; transform: scale(1.2); }
        }
        
        @keyframes connectionPulse {
            0%, 100% { opacity: 0; transform: scaleX(0); }
            50% { opacity: 0.15; transform: scaleX(1); }
        }
        
        /* Enhanced hover effects with constellation response */
        .link-item:hover .link-constellation {
            opacity: 0.25;
        }
        
        .link-item:hover .link-star {
            animation-duration: 2s; /* Faster twinkling on hover */
        }
        .link-item.left  { justify-content: flex-start; }
        .link-item.center{ justify-content: center; }
        .link-item.right { justify-content: flex-end; }
        .link-item.physical-copy {
            color: #ff4444;
            border-color: #444;
            text-transform: none;
            font-size: 14px; letter-spacing: 1.8px;
        }
        .link-item:hover {
            border-color: #666; background: rgba(255,255,255,0.08);
            transform: translateY(-1px); color: #fff;
        }
        .link-item.physical-copy:hover {
            border-color: #ff4444; background: rgba(255,68,68,0.05);
        }
        .link-item::after {
            content: '';
            position: absolute; top: 0; right: 0; bottom: 0; width: 60%;
            background: linear-gradient(to right,rgba(255,255,255,0) 0%,rgba(255,255,255,0.01) 70%,rgba(255,255,255,0.02) 100%);
            pointer-events: none; z-index: 1;
        }

        /* Enhanced Lyric Whisper System - Death Note inspired subliminal effects */
        .lyric-whisper {
            position: absolute; 
            font-size: 12px; 
            color: rgba(255, 68, 68, 0.25); /* More subtle base opacity */
            font-weight: 300; 
            letter-spacing: 1.8px;
            text-transform: uppercase;
            pointer-events: none; 
            z-index: 3;
            opacity: 0;
            text-shadow: 0 0 6px rgba(255, 68, 68, 0.3), 0 0 12px rgba(255, 68, 68, 0.1);
            font-family: 'Courier New', monospace;
            filter: blur(0.5px); /* Slight blur for subliminal effect */
        }

        /* Glitch effect for single words */
        .lyric-whisper.single-word {
            animation-duration: 0.3s;
            color: rgba(255, 68, 68, 0.6);
            text-shadow: 
                2px 0 rgba(255, 68, 68, 0.4),
                -2px 0 rgba(68, 255, 255, 0.2),
                0 0 8px rgba(255, 68, 68, 0.5);
            filter: none;
        }

        /* Peripheral vision effect */
        .lyric-whisper.peripheral {
            font-size: 10px;
            opacity: 0.15;
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 3px;
            filter: blur(1px);
        }

        /* Cryptic letter positioning */
        .lyric-whisper .letter {
            display: inline-block;
            position: relative;
        }

        .lyric-whisper .letter.up {
            transform: translateY(-1px);
        }

        .lyric-whisper .letter.down {
            transform: translateY(1px);
        }

        .lyric-whisper .letter.up2 {
            transform: translateY(-2px);
        }

        .lyric-whisper .letter.down2 {
            transform: translateY(2px);
        }

        /* Positioning for specific negative spaces */
        .link-item:nth-child(1) .lyric-whisper {
            right: 15%; /* position in right negative space of SPOTIFY */
            top: 50%;
            transform: translateY(-50%);
        }

        .link-item:nth-child(2) .lyric-whisper {
            left: 15%; /* position in left negative space of APPLE MUSIC */
            top: 50%;
            transform: translateY(-50%);
        }

        .link-item:nth-child(3) .lyric-whisper.left-space {
            left: 15%; /* left negative space of BEREAL */
            top: 50%;
            transform: translateY(-50%);
        }

        .link-item:nth-child(3) .lyric-whisper.right-space {
            right: 15%; /* right negative space of BEREAL */
            top: 50%;
            transform: translateY(-50%);
        }

        .link-item:nth-child(4) .lyric-whisper {
            right: 15%; /* position in right negative space of INSTAGRAM */
            top: 50%;
            transform: translateY(-50%);
        }

        .link-item:nth-child(5) .lyric-whisper {
            left: 15%; /* position in left negative space of FACEBOOK */
            top: 50%;
            transform: translateY(-50%);
        }

        /* Dynamic phrase animation - multiple variants */
        .lyric-whisper.active {
            animation: wordAppear 0.8s ease-in-out forwards;
        }

        .lyric-whisper.single-word.active {
            animation: glitchFlash 0.3s ease-in-out forwards;
        }

        .lyric-whisper.peripheral.active {
            animation: subliminalFlash 0.2s ease-in-out forwards;
        }

        @keyframes wordAppear {
            0% { opacity: 0; transform: translateY(-50%) scale(0.9); }
            50% { opacity: 0.6; transform: translateY(-50%) scale(1); }
            100% { opacity: 0.25; transform: translateY(-50%) scale(1); }
        }

        @keyframes glitchFlash {
            0% { opacity: 0; transform: translateY(-50%) translateX(0); }
            20% { opacity: 0.8; transform: translateY(-50%) translateX(2px); }
            40% { opacity: 0.6; transform: translateY(-50%) translateX(-1px); }
            60% { opacity: 0.9; transform: translateY(-50%) translateX(1px); }
            80% { opacity: 0.4; transform: translateY(-50%) translateX(0); }
            100% { opacity: 0; transform: translateY(-50%) translateX(0); }
        }

        @keyframes subliminalFlash {
            0% { opacity: 0; }
            50% { opacity: 0.2; }
            100% { opacity: 0; }
        }

        .lyric-whisper.fade-out {
            animation: wordFadeOut 2s ease-in-out forwards;
        }

        @keyframes wordFadeOut {
            0% { opacity: 0.4; }
            100% { opacity: 0; }
        }

        .background-lattice {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            pointer-events: none; z-index: 1; opacity: 0.3;
        }
        .lattice-node {
            position: absolute;
            background: radial-gradient(circle,rgba(255,255,255,0.8) 0%,rgba(255,255,255,0.5) 30%,rgba(255,255,255,0.1) 70%,rgba(255,255,255,0) 100%);
            border-radius: 50%; width: 3px; height: 3px;
            box-shadow: 0 0 4px rgba(255,255,255,0.3);
            animation: nodePulse 30s ease-in-out infinite;
        }
        @keyframes nodePulse {
            0%,100%{opacity:0;transform:scale(0.3);}
            25%{opacity:0.6;transform:scale(1);}
            50%{opacity:0.8;transform:scale(1.2);}
            75%{opacity:0.4;transform:scale(0.8);}
        }
        .lattice-connection {
            position: absolute;
            background: linear-gradient(90deg,rgba(255,255,255,0) 0%,rgba(255,255,255,0.2) 50%,rgba(255,255,255,0) 100%);
            height: 1px; transform-origin: left center;
            animation: connectionFlow 40s ease-in-out infinite;
            box-shadow: 0 0 2px rgba(255,255,255,0.1);
        }
        @keyframes connectionFlow {
            0%,100%{opacity:0;transform:scaleX(0);}
            25%{opacity:0.3;transform:scaleX(0.6);}
            50%{opacity:0.5;transform:scaleX(1);}
            75%{opacity:0.2;transform:scaleX(0.4);}
        }
        .footer {
            margin-top: 50px;
            opacity: 0.7;
            font-size: 12px;
            color: #fff; letter-spacing: 0.8px; line-height: 1.6; text-align: center;
        }
        .footer .quote-line { display: block; margin-bottom: 2px;}
        .footer .author { margin-top: 8px; opacity: 0.6; font-style: italic;}
        @media (max-width: 480px) {
            .container {
                padding: 0 10px;
            }
            .profile-name {
                font-size: 24px;
            }
            .link-item {
                padding: 14px 18px; font-size: 14px; letter-spacing: 2px;
            }
            .lyric-whisper { 
                font-size: 9px; 
                letter-spacing: 1px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="profile-section">
            <div class="profile-image"></div>
            <h1 class="profile-name">Thomas LeRoy Meier</h1>
        </div>
        <div class="links-container">
            <a href="https://open.spotify.com/artist/yourid" class="link-item left" target="_blank">
                <span>SPOTIFY</span>
                <div class="lyric-whisper"></div>
                <div class="link-constellation"></div>
            </a>
            
            <a href="https://music.apple.com/artist/yourid" class="link-item right" target="_blank">
                <span>APPLE MUSIC</span>
                <div class="lyric-whisper"></div>
                <div class="link-constellation"></div>
            </a>
            
            <a href="http://bere.al/heliotropic" class="link-item center" target="_blank">
                <span>BeReal</span>
                <div class="lyric-whisper left-space"></div>
                <div class="lyric-whisper right-space"></div>
                <div class="link-constellation"></div>
            </a>
            
            <a href="https://instagram.com/thomaslistens" class="link-item left" target="_blank">
                <span>INSTAGRAM</span>
                <div class="lyric-whisper"></div>
                <div class="link-constellation"></div>
            </a>
            
            <a href="https://facebook.com/thomaslistens" class="link-item right" target="_blank">
                <span>FACEBOOK</span>
                <div class="lyric-whisper"></div>
                <div class="link-constellation"></div>
            </a>
            
            <a href="mailto:your.email@example.com" class="link-item physical-copy center">
                <span>Handmade Physical Copy &lt;3<br>($30)</span>
            </a>
        </div>
        <div class="footer">
            <span class="quote-line">"When the air is clear,</span>
            <span class="quote-line">you might hear the sounds."</span>
            <span class="author">- Pauline Oliveros</span>
        </div>
        <!-- Dynamic background lattice -->
        <div class="background-lattice" id="backgroundLattice"></div>
    </div>
    <script>
    // Breathing cosmic soundscape - B drone with wandering harmonics
let audioContext;
let masterGain;
let audioInitialized = false;
let activeTones = [];

const fundamental = 123.47; // B2 drone

function createCloudTone(frequency, baseGain, breathRate, breathDepth, fadeInTime, sustainTime, fadeOutTime, startDelay) {
    const ct = audioContext.currentTime;
    
    // Create oscillator and gain
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    // Create LFO for breathing
    const lfo = audioContext.createOscillator();
    const lfoGain = audioContext.createGain();
    
    // Configure LFO
    lfo.type = 'sine';
    lfo.frequency.setValueAtTime(breathRate, ct);
    lfoGain.gain.setValueAtTime(baseGain * breathDepth, ct);
    
    // Connect LFO to modulate gain
    lfo.connect(lfoGain);
    lfoGain.connect(gainNode.gain);
    
    // Connect main audio path
    oscillator.connect(gainNode);
    gainNode.connect(masterGain);
    
    // Configure oscillator
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(frequency, ct);
    
    // Create envelope - gentle fade in, sustain, gentle fade out
    gainNode.gain.setValueAtTime(0, ct + startDelay);
    gainNode.gain.linearRampToValueAtTime(baseGain, ct + startDelay + fadeInTime);
    gainNode.gain.setValueAtTime(baseGain, ct + startDelay + fadeInTime + sustainTime);
    gainNode.gain.linearRampToValueAtTime(0, ct + startDelay + fadeInTime + sustainTime + fadeOutTime);
    
    // Start oscillators
    oscillator.start(ct + startDelay);
    lfo.start(ct + startDelay);
    
    // Stop after envelope completes
    const totalTime = startDelay + fadeInTime + sustainTime + fadeOutTime;
    oscillator.stop(ct + totalTime + 1);
    lfo.stop(ct + totalTime + 1);
    
    // Store for tracking
    activeTones.push({ 
        osc: oscillator, 
        lfo: lfo,
        endTime: ct + totalTime
    });
    
    return totalTime;
}

function createToneCycle(toneConfig) {
    const { frequency, baseGain, breathRate, breathDepth, timing } = toneConfig;
    
    function scheduleTone() {
        if (!audioInitialized) return;
        
        const fadeIn = timing.fadeIn + Math.random() * 5;    // 8-13s fade in
        const sustain = timing.sustain + Math.random() * 10; // 15-25s sustain
        const fadeOut = timing.fadeOut + Math.random() * 5;  // 8-13s fade out
        const pause = timing.pause + Math.random() * 15;     // pause between appearances
        
        const totalTime = createCloudTone(
            frequency,
            baseGain,
            breathRate + (Math.random() - 0.5) * 0.02, // slight breath variation
            breathDepth,
            fadeIn,
            sustain,
            fadeOut,
            0
        );
        
        // Schedule next appearance
        setTimeout(() => scheduleTone(), (totalTime + pause) * 1000);
    }
    
    // Initial delay before first appearance
    setTimeout(() => scheduleTone(), timing.initialDelay * 1000);
}

function initAudioSystem() {
    if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (audioContext.state === 'suspended') audioContext.resume();
    
    if (!audioInitialized) {
        masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        masterGain.gain.setValueAtTime(0.5, audioContext.currentTime); // Softer overall

        // 1. B2 drone (1/1) - always present, gentle breathing
        createBreathingTone(
            fundamental,           // B2
            0.08,                 // softer base gain
            0.15,                 // breath rate (~9/min)
            0.3,                  // 30% breath depth
            0                     // immediate
        );

        // 2. Perfect fifth (3/2) - major triad member
        createToneCycle({
            frequency: fundamental * 3/2,     // F#3
            baseGain: 0.05,                  // soft
            breathRate: 0.13,
            breathDepth: 0.25,
            timing: {
                fadeIn: 8,
                sustain: 15,
                fadeOut: 8,
                pause: 10,
                initialDelay: 5
            }
        });

        // 3. Major third (5/4) - highest, major triad member
        createToneCycle({
            frequency: fundamental * 5/4 * 4, // D#5 (two octaves above)
            baseGain: 0.04,                  // soft but cuts through
            breathRate: 0.14,
            breathDepth: 0.2,
            timing: {
                fadeIn: 10,
                sustain: 20,
                fadeOut: 10,
                pause: 15,
                initialDelay: 8
            }
        });

        // 4. Major seventh (15/8) - filling tone
        createToneCycle({
            frequency: fundamental * 15/8,    // A#3
            baseGain: 0.03,                  // very soft
            breathRate: 0.17,
            breathDepth: 0.2,
            timing: {
                fadeIn: 12,
                sustain: 18,
                fadeOut: 12,
                pause: 20,
                initialDelay: 15
            }
        });

        // 5. Septimal tritone (7/5) - octave above
        createToneCycle({
            frequency: fundamental * 7/5 * 2, // F4
            baseGain: 0.025,                 // very soft
            breathRate: 0.11,
            breathDepth: 0.15,
            timing: {
                fadeIn: 15,
                sustain: 12,
                fadeOut: 15,
                pause: 25,
                initialDelay: 20
            }
        });

        // 6. Harmonic seventh (7/4) - most subtle
        createToneCycle({
            frequency: fundamental * 7/4 * 2, // A4
            baseGain: 0.015,                 // barely there
            breathRate: 0.19,
            breathDepth: 0.1,
            timing: {
                fadeIn: 18,
                sustain: 10,
                fadeOut: 18,
                pause: 30,
                initialDelay: 30
            }
        });

        audioInitialized = true;
        console.log('Cloud-like harmonic soundscape initialized');
    }
}

// Keep the constant drone helper
function createBreathingTone(frequency, baseGain, breathRate, breathDepth, startDelay = 0) {
    const ct = audioContext.currentTime;
    
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    const lfo = audioContext.createOscillator();
    const lfoGain = audioContext.createGain();
    
    lfo.type = 'sine';
    lfo.frequency.setValueAtTime(breathRate, ct);
    lfoGain.gain.setValueAtTime(baseGain * breathDepth, ct);
    
    lfo.connect(lfoGain);
    lfoGain.connect(gainNode.gain);
    oscillator.connect(gainNode);
    gainNode.connect(masterGain);
    
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(frequency, ct);
    
    // Gentle fade in for drone
    gainNode.gain.setValueAtTime(0, ct);
    gainNode.gain.linearRampToValueAtTime(baseGain, ct + 10); // 10 second fade in
    
    oscillator.start(ct + startDelay);
    lfo.start(ct + startDelay);
}

        // ---- Dynamic lattice visuals ----
        let latticeNodes = [];
        let latticeConnections = [];
        let isBuilding = true;
        
        function generateDynamicLattice() {
            const container = document.getElementById('backgroundLattice');
            if (isBuilding) buildLattice(container);
            else dissipateCurrentLattice();
            isBuilding = !isBuilding;
        }
        
        function buildLattice(container) {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const centerX = width / 2;
            const spacing = 120;
            latticeNodes = [];
            latticeConnections = [];
            
            // Generate nodes with exclusion zone around content
            for (let x = spacing; x < width - spacing; x += spacing) {
                for (let y = spacing; y < height - spacing; y += spacing) {
                    if (Math.abs(x - centerX) < 300 && y > height * 0.2 && y < height * 0.8) continue;
                    if (Math.random() < 0.7) {
                        const offsetX = (Math.random() - 0.5) * 60;
                        const offsetY = (Math.random() - 0.5) * 60;
                        const node = document.createElement('div');
                        node.className = 'lattice-node';
                        node.style.left = (x + offsetX) + 'px';
                        node.style.top = (y + offsetY) + 'px';
                        node.style.animationDelay = (Math.random() * 30) + 's';
                        node.style.opacity = '0';
                        setTimeout(() => {
                            if (node.parentNode) {
                                node.style.transition = 'opacity 8s ease-in-out';
                                node.style.opacity = '1';
                            }
                        }, Math.random() * 5000);
                        container.appendChild(node);
                        latticeNodes.push({ element: node, x: x + offsetX, y: y + offsetY });
                    }
                }
            }
            // Connect after a delay
            setTimeout(() => connectNodes(container), 3000);
        }
        
        function connectNodes(container) {
            latticeNodes.forEach((node, i) => {
                latticeNodes.slice(i + 1).forEach((otherNode) => {
                    const distance = Math.sqrt(
                        Math.pow(node.x - otherNode.x, 2) +
                        Math.pow(node.y - otherNode.y, 2)
                    );
                    if (distance < 180 && Math.random() < 0.4) {
                        const dx = otherNode.x - node.x;
                        const dy = otherNode.y - node.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        const line = document.createElement('div');
                        line.className = 'lattice-connection';
                        line.style.left = node.x + 'px';
                        line.style.top = node.y + 'px';
                        line.style.width = length + 'px';
                        line.style.transform = `rotate(${angle}deg)`;
                        line.style.animationDelay = Math.random() * 40 + 's';
                        line.style.opacity = '0';
                        setTimeout(() => {
                            if (line.parentNode) {
                                line.style.transition = 'opacity 6s ease-in-out';
                                line.style.opacity = '1';
                            }
                        }, Math.random() * 8000);
                        container.appendChild(line);
                        latticeConnections.push(line);
                    }
                });
            });
        }
        
        function dissipateCurrentLattice() {
            [...latticeNodes, ...latticeConnections].forEach(item => {
                const element = item.element || item;
                if (element && element.parentNode) {
                    element.style.transition = 'opacity 12s ease-in-out';
                    element.style.opacity = '0';
                    setTimeout(() => {
                        if (element.parentNode) element.remove();
                    }, 12000);
                }
            });
            latticeNodes = [];
            latticeConnections = [];
        }

        // Create subtle constellation effects within each link
        function createLinkConstellations() {
            const linkConstellations = document.querySelectorAll('.link-constellation');
            
            linkConstellations.forEach((constellation, linkIndex) => {
                // Create 3-5 stars per link
                const starCount = Math.floor(Math.random() * 3) + 3;
                const stars = [];
                
                for (let i = 0; i < starCount; i++) {
                    const star = document.createElement('div');
                    star.className = 'link-star';
                    
                    // Position stars avoiding text area (center 60%)
                    let x, y;
                    if (Math.random() > 0.5) {
                        // Left or right edges
                        x = Math.random() > 0.5 ? Math.random() * 20 : 80 + Math.random() * 20;
                    } else {
                        // Top or bottom areas
                        x = 20 + Math.random() * 60;
                        y = Math.random() > 0.5 ? Math.random() * 30 : 70 + Math.random() * 30;
                    }
                    
                    if (y === undefined) y = 20 + Math.random() * 60;
                    
                    star.style.left = x + '%';
                    star.style.top = y + '%';
                    star.style.animationDelay = (Math.random() * 4) + 's';
                    
                    constellation.appendChild(star);
                    stars.push({ element: star, x, y });
                }
                
                // Create connections between nearby stars
                stars.forEach((star, i) => {
                    stars.slice(i + 1).forEach(otherStar => {
                        const distance = Math.sqrt(
                            Math.pow(star.x - otherStar.x, 2) + 
                            Math.pow(star.y - otherStar.y, 2)
                        );
                        
                        // Connect stars that are close but not too close
                        if (distance < 40 && distance > 15 && Math.random() < 0.6) {
                            const connection = document.createElement('div');
                            connection.className = 'link-connection';
                            
                            const dx = otherStar.x - star.x;
                            const dy = otherStar.y - star.y;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                            
                            connection.style.left = star.x + '%';
                            connection.style.top = star.y + '%';
                            connection.style.width = length + '%';
                            connection.style.transform = `rotate(${angle}deg)`;
                            connection.style.animationDelay = (Math.random() * 6) + 's';
                            
                            constellation.appendChild(connection);
                        }
                    });
                });
            });
            
            // Refresh constellations periodically for dynamic feel
            setTimeout(() => {
                linkConstellations.forEach(constellation => {
                    constellation.innerHTML = '';
                });
                createLinkConstellations();
            }, 30000); // Refresh every 30 seconds
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Lyric whisper system - subliminal cryptic messages from Thomas's music
            const phrases = [
                // Intense/desperate phrases - ALL CAPS
                ["ITS", "HARD", "TO", "BREATHE"],
                ["TOO", "DARK", "TO", "SEE"],
                ["I", "WILL", "STAY"],
                ["THIS", "IS", "ALL", "I", "AM"],
                ["BURNING", "ALIVE"],
                ["I", "SEE", "YOU"],
                ["DONT", "LET", "ME", "LIE"],
                ["FOLLOW"],
                ["should", "i", "go?"],
                
                // Gentle/intimate phrases - lowercase
                ["love", "has", "a", "way"],
                ["love", "always", "knows"],
                ["love", "holds", "its", "own"],
                ["your", "heart", "will", "hear"],
                ["its", "the", "light"],
                ["nowhere", "else", "to", "go"],
                ["never", "knows"],
                ["hear", "eye"],
                ["hold", "on", "dearly"],
                ["truth", "can", "take", "all", "night"],
                
                // Subliminal fragments - mixed case
                ["BURNING"],
                ["FOLLOW"],
                ["LISTEN"],
                ["REMEMBER"],
                ["stay"],
                ["see"],
                ["hear"],
                ["truth"],
                ["HOLD"],
                ["dearly"]
            ];

            // Get all lyric whisper elements
            const whisperElements = Array.from(document.querySelectorAll('.lyric-whisper'));

            // Define the sequential order of whisper positions
            // 0: Spotify right, 1: Apple left, 2: BeReal left, 3: BeReal right, 4: Instagram right, 5: Facebook left
            const whisperOrder = [
                whisperElements[0], // Spotify
                whisperElements[1], // Apple Music  
                whisperElements[2], // BeReal left
                whisperElements[3], // BeReal right
                whisperElements[4], // Instagram
                whisperElements[5]  // Facebook
            ];

            function createCrypticWord(word) {
                const letters = word.split('');
                const crypticClasses = ['', 'up', 'down', 'up2', 'down2'];
                
                return letters.map(letter => {
                    const randomClass = Math.random() < 0.4 ? crypticClasses[Math.floor(Math.random() * crypticClasses.length)] : '';
                    return `<span class="letter ${randomClass}">${letter}</span>`;
                }).join('');
            }

            function displayPhrase(phraseWords, startPos) {
                // Clear all whispers first
                whisperElements.forEach(el => {
                    el.classList.remove('active', 'fade-out', 'single-word', 'peripheral');
                    el.innerHTML = '';
                });

                // Determine phrase type for different effects
                const isSingleWord = phraseWords.length === 1;
                const isPeripheral = Math.random() < 0.3; // 30% chance for peripheral effect

                // Display words sequentially from the starting position
                phraseWords.forEach((word, index) => {
                    const positionIndex = startPos + index;
                    if (positionIndex < whisperOrder.length && whisperOrder[positionIndex]) {
                        setTimeout(() => {
                            const element = whisperOrder[positionIndex];
                            element.innerHTML = createCrypticWord(word);
                            
                            // Apply appropriate effect classes
                            if (isSingleWord) {
                                element.classList.add('single-word');
                            } else if (isPeripheral) {
                                element.classList.add('peripheral');
                            }
                            
                            element.classList.add('active');
                        }, index * (isSingleWord ? 0 : 400)); // Faster timing: 0.4s between words
                    }
                });

                // Fade out timing based on phrase type
                const sustainTime = isSingleWord ? 300 : 2000; // Single words flash quickly
                setTimeout(() => {
                    phraseWords.forEach((word, index) => {
                        const positionIndex = startPos + index;
                        if (positionIndex < whisperOrder.length && whisperOrder[positionIndex]) {
                            whisperOrder[positionIndex].classList.remove('active');
                            whisperOrder[positionIndex].classList.add('fade-out');
                        }
                    });
                }, phraseWords.length * (isSingleWord ? 0 : 400) + sustainTime);
            }

            function startLyricCycle() {
                let lastStartPos = -1; // Track the last starting position
                
                function nextPhrase() {
                    const randomIndex = Math.floor(Math.random() * phrases.length);
                    const phrase = phrases[randomIndex];
                    
                    // Get valid starting positions for this phrase length
                    const maxStartPos = Math.min(3, whisperOrder.length - phrase.length);
                    const validPositions = [];
                    for (let i = 0; i <= maxStartPos; i++) {
                        validPositions.push(i);
                    }
                    
                    // Remove the last used position to avoid repetition (if possible)
                    if (validPositions.length > 1 && validPositions.includes(lastStartPos)) {
                        validPositions.splice(validPositions.indexOf(lastStartPos), 1);
                    }
                    
                    // Choose a random position from remaining valid positions
                    const startPos = validPositions[Math.floor(Math.random() * validPositions.length)];
                    lastStartPos = startPos;
                    
                    displayPhrase(phrase, startPos);
                    
                    // Much faster cycles - Death Note psychological pressure
                    const isSingleWord = phrase.length === 1;
                    const baseDelay = isSingleWord ? 1500 : 3000; // Quick single words, moderate phrases
                    const randomDelay = Math.random() * 2000 + 1000; // 1-3s additional randomness
                    const cycleDelay = baseDelay + randomDelay;
                    
                    setTimeout(nextPhrase, cycleDelay);
                }
                
                // Start first phrase immediately after page load - no waiting
                setTimeout(nextPhrase, 1500);
            }

            // Animate staggered link fade-in
            document.querySelectorAll('.link-item').forEach((link, idx) => {
                link.style.animationDelay = `${idx * 0.1}s`;
                link.style.animation = 'fadeInUp 0.6s ease-out forwards';
                link.style.opacity = '0';
            });
            
            // Start lyric system
            startLyricCycle();
            
            // Create link constellations
            createLinkConstellations();
            
            // Start lattice visual
            generateDynamicLattice();
            setInterval(generateDynamicLattice, 45000);
            window.addEventListener('resize', () => {
                document.getElementById('backgroundLattice').innerHTML = '';
                generateDynamicLattice();
            });
            
            // Audio: trigger on first user input
            function start() { initAudioSystem(); }
            document.addEventListener('click', start, { once: true });
            document.addEventListener('keydown', start, { once: true });
        });

        // Subtle floating particles
        function createEtherealParticle() {
            const particle = document.createElement('div');
            particle.style.position = 'fixed';
            particle.style.width = '1px';
            particle.style.height = '1px';
            particle.style.background = 'rgba(255, 255, 255, 0.4)';
            particle.style.borderRadius = '50%';
            particle.style.pointerEvents = 'none';
            particle.style.left = Math.random() * window.innerWidth + 'px';
            particle.style.top = window.innerHeight + 'px';
            particle.style.zIndex = '0';
            particle.style.boxShadow = '0 0 3px rgba(255, 255, 255, 0.3)';
            
            document.body.appendChild(particle);
            
            const animation = particle.animate([
                { 
                    transform: 'translateY(0px) translateX(0px)', 
                    opacity: 0.6 
                },
                { 
                    transform: `translateY(-${window.innerHeight + 100}px) translateX(${(Math.random() - 0.5) * 200}px)`, 
                    opacity: 0 
                }
            ], {
                duration: Math.random() * 12000 + 8000, // 8-20 seconds
                easing: 'ease-out'
            });
            
            animation.onfinish = () => particle.remove();
        }
        
    </script>
</body>
</html>