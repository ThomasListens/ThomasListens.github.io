<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Metabolic Harmonics v25</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500&family=IBM+Plex+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #fafafa;
  --panel: #ffffff;
  --text: #1a1a1a;
  --dim: #888;
  --border: #e8e8e8;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: 'IBM Plex Sans', sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
}

.container {
  display: grid;
  grid-template-columns: 220px 1fr;
  grid-template-rows: auto 1fr auto;
  min-height: 100vh;
}

.header {
  grid-column: 1 / -1;
  padding: 10px 20px;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: var(--panel);
}
.header h1 { font-size: 14px; font-weight: 600; letter-spacing: -0.3px; }
.header-meta { font-size: 9px; color: var(--dim); font-family: 'IBM Plex Mono', monospace; }

.sidebar {
  grid-row: 2 / 4;
  padding: 14px;
  border-right: 1px solid var(--border);
  background: var(--panel);
  font-size: 10px;
  overflow-y: auto;
}
.sidebar h3 {
  font-size: 8px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--dim);
  margin: 12px 0 5px;
}
.sidebar h3:first-child { margin-top: 0; }

.condition-btn {
  display: block;
  width: 100%;
  padding: 7px 9px;
  margin-bottom: 3px;
  background: transparent;
  border: 1px solid var(--border);
  border-radius: 3px;
  font-family: inherit;
  font-size: 9px;
  text-align: left;
  cursor: pointer;
  transition: all 0.15s;
}
.condition-btn:hover { background: #f5f5f5; }
.condition-btn.active { background: var(--text); color: white; border-color: var(--text); }
.condition-btn small { display: block; font-size: 7px; color: var(--dim); margin-top: 1px; }
.condition-btn.active small { color: rgba(255,255,255,0.6); }

.scale-toggle {
  display: flex; align-items: center; gap: 5px;
  margin: 5px 0; cursor: pointer; font-size: 9px;
}
.scale-toggle input { width: 11px; height: 11px; }

.color-select {
  width: 100%;
  padding: 5px;
  border: 1px solid var(--border);
  border-radius: 3px;
  font-family: inherit;
  font-size: 8px;
  margin-top: 3px;
}

.gradient-legend { 
  margin-top: 8px; 
  padding: 6px; 
  background: #f5f5f5; 
  border-radius: 3px; 
}
.gradient-legend h4 { 
  font-size: 7px; 
  text-transform: uppercase; 
  letter-spacing: 0.5px; 
  color: var(--dim); 
  margin-bottom: 3px; 
}
.gradient-bar {
  height: 8px; 
  border-radius: 2px;
  margin-bottom: 2px;
  background: linear-gradient(90deg,
    hsl(215, 70%, 60%) 0%,
    hsl(165, 60%, 52%) 15%,
    hsl(48, 85%, 55%) 35%,
    hsl(22, 80%, 58%) 55%,
    hsl(340, 70%, 60%) 75%,
    hsl(280, 55%, 62%) 100%);
}
.gradient-labels { 
  display: flex; 
  justify-content: space-between; 
  font-size: 6px; 
  color: var(--dim); 
}

.info-panel {
  margin-top: 10px;
  padding: 8px;
  background: linear-gradient(135deg, #f8f9fa 0%, #f0f4f8 100%);
  border-radius: 4px;
  border: 1px solid var(--border);
}
.info-panel h4 {
  font-size: 7px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--dim);
  margin-bottom: 6px;
}
.info-row {
  display: flex;
  justify-content: space-between;
  font-size: 8px;
  margin-bottom: 2px;
  padding: 2px 0;
}
.info-row .label { color: var(--dim); }
.info-row .value { 
  font-family: 'IBM Plex Mono', monospace; 
  font-weight: 500;
  max-width: 100px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.voice-indicator {
  margin-top: 8px;
  padding: 6px;
  background: #f5f5f5;
  border-radius: 3px;
}
.voice-indicator h4 {
  font-size: 7px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--dim);
  margin-bottom: 3px;
}
.voice-bar {
  height: 4px;
  background: #e0e0e0;
  border-radius: 2px;
  overflow: hidden;
}
.voice-fill {
  height: 100%;
  background: linear-gradient(90deg, #4dabf7, #74c0fc);
  width: 0%;
  transition: width 0.2s ease;
  border-radius: 2px;
}
.voice-count {
  font-size: 7px;
  color: var(--dim);
  margin-top: 2px;
  text-align: right;
}

.viz {
  position: relative;
  background: var(--bg);
  overflow: hidden;
}

.bar {
  cursor: pointer;
  will-change: transform, opacity;
  transform-origin: bottom center;
  transform-box: fill-box;
}

.axis text { font-family: 'IBM Plex Mono', monospace; font-size: 8px; fill: var(--dim); }
.axis path, .axis line { stroke: #e8e8e8; }

.bottom-panel {
  grid-column: 2;
  display: grid;
  grid-template-columns: 1fr 160px;
  border-top: 1px solid var(--border);
  background: var(--panel);
  height: 70px;
}

.audio-viz {
  display: grid;
  grid-template-columns: 1fr 1fr;
  background: #0a0a0a;
  padding: 6px 10px;
  gap: 8px;
}
.audio-section {
  display: flex;
  flex-direction: column;
}
.audio-section label {
  font-size: 6px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #444;
  margin-bottom: 2px;
}
.audio-section canvas { 
  flex: 1;
  width: 100%; 
  border-radius: 2px;
  background: #111;
}

.status-panel {
  padding: 8px 12px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  border-left: 1px solid var(--border);
}
.status-panel .state {
  font-size: 7px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--dim);
  margin-bottom: 2px;
}
.status-panel .state-value {
  font-size: 11px;
  font-weight: 600;
  font-family: 'IBM Plex Mono', monospace;
  color: var(--text);
}
.status-panel .sub {
  font-size: 7px;
  color: var(--dim);
  margin-top: 4px;
}

.overlay {
  position: absolute;
  inset: 0;
  background: rgba(250,250,250,0.97);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 100;
  transition: opacity 0.6s;
}
.overlay.hidden { opacity: 0; pointer-events: none; }
.play-circle {
  width: 56px; height: 56px;
  border: 2px solid var(--text);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 8px;
  transition: all 0.2s;
}
.overlay:hover .play-circle { background: var(--text); }
.overlay:hover .play-circle svg { fill: white; }
.play-circle svg { fill: var(--text); margin-left: 2px; }
.overlay p { font-size: 9px; color: var(--dim); }

.progress-bar {
  position: absolute;
  bottom: 0; left: 0;
  height: 2px;
  background: var(--text);
  width: 0%;
}

.zoom-reset {
  position: absolute;
  top: 6px;
  right: 6px;
  padding: 3px 7px;
  background: white;
  border: 1px solid var(--border);
  border-radius: 2px;
  font-size: 7px;
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.2s;
  z-index: 10;
}
.zoom-reset.visible { opacity: 1; }
</style>
</head>

<body>
<div class="container">
  <header class="header">
    <h1>Metabolic Harmonics</h1>
    <div class="header-meta" id="headerMeta">Loading...</div>
  </header>

  <aside class="sidebar">
    <h3>Source</h3>
    <button class="condition-btn active">
      Healthy Reference
      <small>14,562 samples</small>
    </button>
    <button class="condition-btn">
      Gut Microbiome
      <small>Stool samples</small>
    </button>

    <h3>Display</h3>
    <label class="scale-toggle">
      <input type="checkbox" id="scaleToggle" checked>
      Symlog scale
    </label>
    
    <select class="color-select" id="colorMode">
      <option value="combined">Prime Blend</option>
      <option value="complexity">Complexity</option>
      <option value="prime">Prime Limit</option>
      <option value="spectral">Frequency</option>
    </select>

    <div class="gradient-legend">
      <h4>Color Map</h4>
      <div class="gradient-bar"></div>
      <div class="gradient-labels">
        <span>2-limit</span>
        <span>13+</span>
      </div>
    </div>
    
    <div class="info-panel" id="infoPanel">
      <h4>Focused Pathway</h4>
      <div class="info-row"><span class="label">Name</span><span class="value" id="infoPathway">—</span></div>
      <div class="info-row"><span class="label">Ratio</span><span class="value" id="infoRatio">—</span></div>
      <div class="info-row"><span class="label">Frequency</span><span class="value" id="infoFreq">—</span></div>
      <div class="info-row"><span class="label">Amplitude</span><span class="value" id="infoAmp">—</span></div>
      <div class="info-row"><span class="label">Prime</span><span class="value" id="infoPrime">—</span></div>
    </div>
    
    <div class="voice-indicator">
      <h4>Voices</h4>
      <div class="voice-bar">
        <div class="voice-fill" id="voiceFill"></div>
      </div>
      <div class="voice-count"><span id="voiceCount">0</span> / <span id="voiceMax">16</span></div>
    </div>
  </aside>

  <div class="viz" id="viz">
    <button class="zoom-reset" id="zoomReset">Reset</button>
    <div class="overlay" id="overlay">
      <div class="play-circle">
        <svg width="18" height="18" viewBox="0 0 24 24">
          <polygon points="6,3 20,12 6,21"/>
        </svg>
      </div>
      <p id="overlayText">Loading...</p>
    </div>
    <svg id="chart"></svg>
    <div class="progress-bar" id="progressBar"></div>
  </div>

  <div class="bottom-panel">
    <div class="audio-viz">
      <div class="audio-section">
        <label>Waveform</label>
        <canvas id="oscCanvas"></canvas>
      </div>
      <div class="audio-section">
        <label>Spectrum</label>
        <canvas id="specCanvas"></canvas>
      </div>
    </div>
    <div class="status-panel">
      <div class="state">State</div>
      <div class="state-value" id="systemState">Dormant</div>
      <div class="sub" id="systemSub">Click to initialize</div>
    </div>
  </div>
</div>

<script>
// ============================================================
// STATE
// ============================================================
let pathwayData = [];
let audioCtx, analyser, masterGain;
let buildBuffer, loopBuffer;
let loopSource = null;
let isBuilding = false;
let buildComplete = false;

// Voices
const MAX_VOICES_SLOW = 4;
const MAX_VOICES_FAST = 20;
let voices = new Map();

// D3
let svg, defs, chartArea, xScale, yScale, xScaleOriginal, bars;
let width, height, margin;
let zoom;
let currentTransform = d3.zoomIdentity;
let widthScale;

// ============================================================
// CURSOR FIELD - The Heart of the Interaction
// ============================================================
let cursorField = {
  freq: null,
  active: false
};

// Mouse tracking
let mouseX = 0, mouseY = 0;
let isMouseInViz = false;
let mouseHistory = [];
const MOUSE_HISTORY_LENGTH = 8;
let currentMouseSpeed = 0;

// Dwell detection
let stillTime = 0;
let lastFrameTime = 0;

// Animation
let barStates = new Map();
let globalTime = 0;
let currentRMS = 0;

// Color
let colorMode = 'combined';

// ============================================================
// FIELD PHYSICS - Velocity-Dependent Parameters
// ============================================================
function getFieldSigma() {
  // Narrow when slow (precision), wide when fast (sweep)
  const minSigma = 0.035;  // pinpoint - very tight
  const maxSigma = 0.25;   // sweeping - broad region
  const t = Math.min(currentMouseSpeed / 70, 1);
  return minSigma + t * (maxSigma - minSigma);
}

function getFieldGain() {
  // Strong when slow (authority), weak when fast (light touch)
  const slowGain = 1.8;
  const fastGain = 0.6;
  const t = Math.min(currentMouseSpeed / 60, 1);
  return slowGain + t * (fastGain - slowGain);
}

function getLensSigma() {
  // Tight focus when slow, wide context when fast
  const minLens = 0.08;
  const maxLens = 0.35;
  const t = Math.min(currentMouseSpeed / 60, 1);
  return minLens + t * (maxLens - minLens);
}

function getMaxVoices() {
  // Few voices when slow (clarity), many when fast (texture)
  const t = Math.min(currentMouseSpeed / 50, 1);
  return Math.round(MAX_VOICES_SLOW + t * (MAX_VOICES_FAST - MAX_VOICES_SLOW));
}

function getBloomLerpRate() {
  const minLerp = 0.03;
  const maxLerp = 0.2;
  const t = Math.min(currentMouseSpeed / 70, 1);
  return minLerp + t * (maxLerp - minLerp);
}

function getDecayLerpRate() {
  return 0.015; // Always slow, dreamy decay
}

function isDwelling() {
  return stillTime > 120;
}

// ============================================================
// PRIME COLORS
// ============================================================
const PRIME_COLORS = {
  2: { h: 215, s: 75, l: 58 },
  3: { h: 160, s: 65, l: 48 },
  5: { h: 48, s: 85, l: 55 },
  7: { h: 22, s: 80, l: 58 },
  11: { h: 340, s: 70, l: 60 },
  13: { h: 280, s: 60, l: 62 },
  'other': { h: 260, s: 40, l: 52 }
};

function getPrimeFactors(n) {
  const factors = {};
  [2, 3, 5, 7, 11, 13].forEach(p => {
    while (n % p === 0) { factors[p] = (factors[p] || 0) + 1; n /= p; }
  });
  if (n > 1) factors['other'] = 1;
  return factors;
}

function getRatioFactors(ratioStr) {
  const [num, den] = ratioStr.split('/').map(Number);
  const nf = getPrimeFactors(num);
  const df = getPrimeFactors(den);
  const all = { ...nf };
  for (const [p, c] of Object.entries(df)) all[p] = (all[p] || 0) + c;
  return all;
}

function getPrimeLimit(ratioStr) {
  const factors = getRatioFactors(ratioStr);
  const primes = [2, 3, 5, 7, 11, 13].filter(p => factors[p]);
  if (factors['other']) return 'higher';
  return primes.length ? Math.max(...primes) : 2;
}

function getBlendedColor(d, mode, maxFreq, maxComplex) {
  if (mode === 'combined') {
    const factors = getRatioFactors(d.ratio);
    const total = Object.values(factors).reduce((a, b) => a + b, 0);
    let h = 0, s = 0, l = 0;
    for (const [prime, count] of Object.entries(factors)) {
      const c = PRIME_COLORS[prime] || PRIME_COLORS['other'];
      const w = count / total;
      h += c.h * w; s += c.s * w; l += c.l * w;
    }
    const ct = d.complexity / maxComplex;
    s *= (1 - ct * 0.2);
    l *= (1 - ct * 0.08);
    const ft = Math.log(d.frequency / 100) / Math.log(maxFreq / 100);
    s *= 0.85 + (1 - ft) * 0.15;
    l += ft * 2;
    return { h, s, l };
  }
  if (mode === 'prime') return PRIME_COLORS[getPrimeLimit(d.ratio)] || PRIME_COLORS['other'];
  if (mode === 'spectral') {
    const t = Math.log(d.frequency / 100) / Math.log(maxFreq / 100);
    return { h: t * 300, s: 75, l: 55 };
  }
  const t = Math.pow(d.complexity / maxComplex, 0.4);
  return { h: 210 + t * 130, s: 70 - t * 15, l: 58 - t * 8 };
}

// ============================================================
// MOUSE VELOCITY TRACKING
// ============================================================
function updateMouseVelocity(x, y, timestamp) {
  mouseHistory.push({ x, y, time: timestamp });
  
  while (mouseHistory.length > MOUSE_HISTORY_LENGTH) {
    mouseHistory.shift();
  }
  
  if (mouseHistory.length >= 2) {
    const oldest = mouseHistory[0];
    const newest = mouseHistory[mouseHistory.length - 1];
    const dt = newest.time - oldest.time;
    const dist = Math.hypot(newest.x - oldest.x, newest.y - oldest.y);
    currentMouseSpeed = dt > 0 ? (dist / dt) * 100 : 0;
  }
  
  // Dwell detection
  if (currentMouseSpeed < 5) {
    stillTime += timestamp - lastFrameTime;
  } else {
    stillTime = 0;
  }
  
  mouseX = x;
  mouseY = y;
}

// ============================================================
// LOAD DATA
// ============================================================
async function loadData() {
  try {
    const resp = await fetch('pathways_656.json');
    pathwayData = await resp.json();
    pathwayData = pathwayData.filter(d => d.amp > 0.000001);
    
    const maxFreq = Math.max(...pathwayData.map(d => d.frequency));
    const maxComplex = Math.max(...pathwayData.map(d => d.complexity));
    const maxAmp = Math.max(...pathwayData.map(d => d.amp));
    
    pathwayData.forEach((d, i) => {
      d.index = i;
      d.primeLimit = getPrimeLimit(d.ratio);
      d.baseColor = getBlendedColor(d, colorMode, maxFreq, maxComplex);
      
      // Growth boost for small bars
      const ampRatio = d.amp / maxAmp;
      d.growthBoost = 1 + (1 - ampRatio) * 2.5;
    });
    
    document.getElementById('headerMeta').textContent = 
      `${pathwayData.length} pathways · 100 Hz fundamental`;
    document.getElementById('overlayText').textContent = 'Click to begin';
    
    initVisualization();
  } catch (e) {
    console.error('Failed to load:', e);
    document.getElementById('overlayText').textContent = 'Error loading data';
  }
}

// ============================================================
// AUDIO
// ============================================================
async function initAudio() {
  if (audioCtx) return;
  
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') await audioCtx.resume();
  
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.4;
  
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  
  masterGain.connect(analyser);
  analyser.connect(audioCtx.destination);
  
  try {
    const [buildResp, loopResp] = await Promise.all([
      fetch('wavetable_build.wav'),
      fetch('wavetable_loop.wav')
    ]);
    const [buildArr, loopArr] = await Promise.all([
      buildResp.arrayBuffer(),
      loopResp.arrayBuffer()
    ]);
    [buildBuffer, loopBuffer] = await Promise.all([
      audioCtx.decodeAudioData(buildArr),
      audioCtx.decodeAudioData(loopArr)
    ]);
  } catch (e) {
    console.warn('WAV files not found');
  }
  
  drawAudioViz();
}

async function playBuild() {
  if (!audioCtx || !buildBuffer) {
    isBuilding = true;
    setTimeout(() => {
      isBuilding = false;
      buildComplete = true;
      updateSystemState('Metabolizing', 'Hover to explore');
      requestAnimationFrame(animationLoop);
    }, 4000);
    return;
  }
  
  isBuilding = true;
  updateSystemState('Building', 'Synthesizing...');
  
  const source = audioCtx.createBufferSource();
  source.buffer = buildBuffer;
  source.connect(masterGain);
  source.start();
  
  source.onended = () => {
    isBuilding = false;
    buildComplete = true;
    startLoop();
    updateSystemState('Metabolizing', 'Hover to explore');
    requestAnimationFrame(animationLoop);
  };
}

function startLoop() {
  if (!loopBuffer) return;
  loopSource = audioCtx.createBufferSource();
  loopSource.buffer = loopBuffer;
  loopSource.loop = true;
  loopSource.connect(masterGain);
  loopSource.start();
}

function updateSystemState(state, sub) {
  document.getElementById('systemState').textContent = state;
  document.getElementById('systemSub').textContent = sub;
}

// ============================================================
// VOICE SYSTEM - Sampled from Excitation Peaks
// ============================================================
function updateVoicesFromField() {
  if (!audioCtx || !isMouseInViz) return;
  
  const maxVoices = getMaxVoices();
  document.getElementById('voiceMax').textContent = maxVoices;
  
  // Get top excited bars
  const excited = pathwayData
    .map(d => ({
      d,
      excitation: barStates.get(d.pathway).excitation
    }))
    .filter(x => x.excitation > 0.15)
    .sort((a, b) => b.excitation - a.excitation)
    .slice(0, maxVoices);
  
  const activePathways = new Set(excited.map(x => x.d.pathway));
  
  // Fade voices not in top excited
  for (const [pathway, voice] of voices) {
    if (!activePathways.has(pathway)) {
      voice.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.15);
      setTimeout(() => {
        try {
          voice.osc.stop();
          voice.vibrato.stop();
          voice.gain.disconnect();
        } catch(e) {}
      }, 600);
      voices.delete(pathway);
    }
  }
  
  // Create/update voices for top excited
  excited.forEach(({ d, excitation }) => {
    const existing = voices.get(d.pathway);
    
    if (existing) {
      // Update gain based on excitation
      const targetGain = 0.07 * excitation;
      existing.gain.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.05);
    } else if (voices.size < maxVoices) {
      // Create new voice
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      // Subtle vibrato for organic feel
      const vibrato = audioCtx.createOscillator();
      const vibratoGain = audioCtx.createGain();
      vibrato.frequency.value = 3.5 + Math.random() * 2.5;
      vibratoGain.gain.value = d.frequency * 0.002;
      vibrato.connect(vibratoGain);
      vibratoGain.connect(osc.frequency);
      vibrato.start();
      
      osc.type = 'sine';
      osc.frequency.value = d.frequency;
      gain.gain.value = 0;
      
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start();
      
      // Attack speed based on velocity
      const attackTime = currentMouseSpeed > 40 ? 0.02 : 0.12;
      gain.gain.setTargetAtTime(0.07 * excitation, audioCtx.currentTime, attackTime);
      
      voices.set(d.pathway, { osc, gain, vibrato, vibratoGain });
    }
  });
  
  updateVoiceIndicator();
}

function fadeAllVoices() {
  for (const [pathway, voice] of voices) {
    voice.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.3);
    setTimeout(() => {
      try {
        voice.osc.stop();
        voice.vibrato.stop();
        voice.gain.disconnect();
      } catch(e) {}
    }, 1200);
  }
  voices.clear();
  updateVoiceIndicator();
}

function updateVoiceIndicator() {
  const count = voices.size;
  const max = getMaxVoices();
  document.getElementById('voiceCount').textContent = count;
  document.getElementById('voiceFill').style.width = `${(count / MAX_VOICES_FAST) * 100}%`;
}

// ============================================================
// AUDIO VIZ
// ============================================================
const oscCanvas = document.getElementById('oscCanvas');
const specCanvas = document.getElementById('specCanvas');
const oscCtx = oscCanvas.getContext('2d');
const specCtx = specCanvas.getContext('2d');

function resizeCanvases() {
  oscCanvas.width = oscCanvas.offsetWidth * 2;
  oscCanvas.height = oscCanvas.offsetHeight * 2;
  specCanvas.width = specCanvas.offsetWidth * 2;
  specCanvas.height = specCanvas.offsetHeight * 2;
}
resizeCanvases();
window.addEventListener('resize', resizeCanvases);

const timeData = new Uint8Array(2048);
const freqData = new Uint8Array(1024);

function drawAudioViz() {
  requestAnimationFrame(drawAudioViz);
  if (!analyser) return;
  
  const oscW = oscCanvas.width, oscH = oscCanvas.height;
  const specW = specCanvas.width, specH = specCanvas.height;
  
  analyser.getByteTimeDomainData(timeData);
  
  let sum = 0;
  for (let i = 0; i < timeData.length; i++) {
    const v = (timeData[i] - 128) / 128;
    sum += v * v;
  }
  currentRMS = Math.sqrt(sum / timeData.length);
  
  oscCtx.fillStyle = '#111';
  oscCtx.fillRect(0, 0, oscW, oscH);
  oscCtx.strokeStyle = '#4dabf7';
  oscCtx.lineWidth = 1.5;
  oscCtx.beginPath();
  for (let i = 0; i < timeData.length; i++) {
    const x = (i / timeData.length) * oscW;
    const y = (timeData[i] / 128) * oscH / 2;
    i === 0 ? oscCtx.moveTo(x, y) : oscCtx.lineTo(x, y);
  }
  oscCtx.stroke();
  
  analyser.getByteFrequencyData(freqData);
  specCtx.fillStyle = '#111';
  specCtx.fillRect(0, 0, specW, specH);
  
  const numBars = 40;
  const barW = specW / numBars;
  for (let i = 0; i < numBars; i++) {
    const idx = Math.floor(Math.pow(i / numBars, 2) * freqData.length * 0.5);
    const val = freqData[idx];
    const h = (val / 255) * specH * 0.85;
    const hue = 200 + (i / numBars) * 140;
    specCtx.fillStyle = `hsl(${hue}, 55%, ${28 + val / 255 * 25}%)`;
    specCtx.fillRect(i * barW + 1, specH - h, barW - 2, h);
  }
}

// ============================================================
// VISUALIZATION
// ============================================================
function initVisualization() {
  const vizEl = document.getElementById('viz');
  margin = { top: 12, right: 16, bottom: 25, left: 40 };
  width = vizEl.clientWidth - margin.left - margin.right;
  height = vizEl.clientHeight - margin.top - margin.bottom;
  
  const maxFreq = Math.max(...pathwayData.map(d => d.frequency));
  const maxAmp = Math.max(...pathwayData.map(d => d.amp));
  
  const svgEl = d3.select('#chart')
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom);
  
  svg = svgEl.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
  
  svg.append('defs').append('clipPath').attr('id', 'chart-clip')
    .append('rect').attr('width', width).attr('height', height);
  
  defs = svg.select('defs');
  chartArea = svg.append('g').attr('clip-path', 'url(#chart-clip)');
  
  xScale = d3.scaleLog().domain([90, maxFreq * 1.1]).range([0, width]);
  xScaleOriginal = xScale.copy();
  yScale = d3.scaleSymlog().constant(0.0001).domain([0, maxAmp * 1.1]).range([height, 0]);
  widthScale = d3.scaleSqrt().domain([0, maxAmp]).range([2, 6]);
  
  // Gradients
  pathwayData.forEach((d, i) => {
    const c = d.baseColor;
    const grad = defs.append('linearGradient')
      .attr('id', `grad-${i}`)
      .attr('x1', '0%').attr('y1', '100%')
      .attr('x2', '0%').attr('y2', '0%');
    
    grad.append('stop').attr('class', 'stop-bot').attr('offset', '0%')
      .attr('stop-color', `hsl(${c.h}, ${c.s}%, ${c.l}%)`);
    grad.append('stop').attr('class', 'stop-mid').attr('offset', '50%')
      .attr('stop-color', `hsl(${c.h}, ${c.s}%, ${c.l + 8}%)`);
    grad.append('stop').attr('class', 'stop-top').attr('offset', '100%')
      .attr('stop-color', `hsl(${c.h}, ${c.s}%, ${c.l}%)`).attr('stop-opacity', 0.5);
  });
  
  // Axes
  svg.append('g').attr('class', 'axis x-axis').attr('transform', `translate(0,${height})`)
    .call(d3.axisBottom(xScale)
      .tickValues([100, 200, 500, 1000, 2000, 5000])
      .tickFormat(d => d >= 1000 ? (d/1000) + 'k' : d));
  
  svg.append('g').attr('class', 'axis y-axis')
    .call(d3.axisLeft(yScale).ticks(3).tickFormat(d3.format('.2f')));
  
  // Bars
  const renderOrder = [...pathwayData].sort((a, b) => b.amp - a.amp);
  
  bars = chartArea.append('g').selectAll('rect')
    .data(renderOrder)
    .enter()
    .append('rect')
    .attr('class', 'bar')
    .attr('x', d => xScale(d.frequency) - widthScale(d.amp) / 2)
    .attr('y', height)
    .attr('width', d => widthScale(d.amp))
    .attr('height', 0)
    .attr('fill', d => `url(#grad-${d.index})`);
  
  // Bar states
  pathwayData.forEach(d => {
    barStates.set(d.pathway, {
      excitation: 0,
      targetOpacity: 1,
      currentScaleX: 1,
      currentScaleY: 1,
      currentOpacity: 1,
      ripplePhase: Math.random() * Math.PI * 2,
      rippleDrift: (Math.random() - 0.5) * 0.04
    });
  });
  
  // Mouse tracking
  chartArea.append('rect')
    .attr('width', width).attr('height', height)
    .attr('fill', 'transparent')
    .lower()
    .on('mouseenter', handleMouseEnter)
    .on('mousemove', handleMouseMove)
    .on('mouseleave', handleMouseLeave);
  
  // Zoom
  zoom = d3.zoom()
    .scaleExtent([1, 50])
    .translateExtent([[0, 0], [width, height]])
    .extent([[0, 0], [width, height]])
    .on('zoom', zoomed);
  
  svgEl.call(zoom);
  svgEl.on('dblclick.zoom', resetZoom);
  document.getElementById('zoomReset').addEventListener('click', resetZoom);
}

// ============================================================
// MOUSE HANDLERS
// ============================================================
function handleMouseEnter() {
  isMouseInViz = true;
  cursorField.active = true;
}

function handleMouseMove(event) {
  if (isBuilding) return;
  
  const [mx, my] = d3.pointer(event);
  const timestamp = performance.now();
  
  updateMouseVelocity(mx, my, timestamp);
  
  // Update cursor field position in FREQUENCY SPACE
  cursorField.freq = xScale.invert(mx);
  cursorField.active = true;
  
  // Find closest bar for info display
  let closestBar = null;
  let closestDist = Infinity;
  
  pathwayData.forEach(d => {
    const freqDist = Math.abs(Math.log(d.frequency / cursorField.freq));
    if (freqDist < closestDist) {
      closestDist = freqDist;
      closestBar = d;
    }
  });
  
  if (closestBar && closestDist < 0.1) {
    updateInfo(closestBar);
    
    if (isDwelling()) {
      updateSystemState('Focused', closestBar.ratio);
    } else if (currentMouseSpeed > 40) {
      updateSystemState('Sweeping', `${voices.size} voices`);
    } else {
      updateSystemState('Resonating', closestBar.ratio);
    }
  }
}

function handleMouseLeave() {
  isMouseInViz = false;
  cursorField.active = false;
  cursorField.freq = null;
  mouseHistory = [];
  currentMouseSpeed = 0;
  stillTime = 0;
  
  fadeAllVoices();
  clearInfo();
  updateSystemState('Metabolizing', 'Hover to explore');
}

function updateInfo(d) {
  document.getElementById('infoPathway').textContent = d.pathway;
  document.getElementById('infoRatio').textContent = d.ratio;
  document.getElementById('infoFreq').textContent = d.frequency.toFixed(1) + ' Hz';
  document.getElementById('infoAmp').textContent = d.amp.toExponential(2);
  document.getElementById('infoPrime').textContent = d.primeLimit + '-limit';
}

function clearInfo() {
  ['infoPathway', 'infoRatio', 'infoFreq', 'infoAmp', 'infoPrime'].forEach(id => {
    document.getElementById(id).textContent = '—';
  });
}

// ============================================================
// ANIMATION LOOP - Field-Based Physics
// ============================================================
function animationLoop(timestamp) {
  requestAnimationFrame(animationLoop);
  
  const deltaTime = timestamp - lastFrameTime;
  lastFrameTime = timestamp;
  globalTime = timestamp * 0.001;
  
  const audioGlow = 1 + currentRMS * 0.15;
  const bloomLerp = getBloomLerpRate();
  const decayLerp = getDecayLerpRate();
  
  // ========================================
  // FIELD EXCITATION - The Core Algorithm
  // ========================================
  if (cursorField.active && cursorField.freq) {
    const sigma = getFieldSigma();
    const gain = getFieldGain();
    const lensSigma = getLensSigma();
    
    // Dwell boost - when still, increase precision
    const dwellBoost = isDwelling() ? 1.4 : 1.0;
    const dwellLensTighten = isDwelling() ? 0.6 : 1.0;
    
    pathwayData.forEach(d => {
      const state = barStates.get(d.pathway);
      
      // Distance in LOG-FREQUENCY space (harmonic distance)
      const freqDist = Math.abs(Math.log(d.frequency / cursorField.freq));
      
      // Gaussian excitation field
      const field = Math.exp(-Math.pow(freqDist / sigma, 2));
      
      // Accumulate excitation
      const exciteAmount = field * gain * dwellBoost * 0.04;
      state.excitation = Math.min(1, state.excitation + exciteAmount);
      
      // Opacity lens - nearby dims, far stays bright
      const lens = Math.exp(-Math.pow(freqDist / (lensSigma * dwellLensTighten), 2));
      
      // Invert: close = dim (unless excited), far = full
      const baseDim = 0.3 + state.excitation * 0.5;
      state.targetOpacity = 1 - lens * (0.6 - state.excitation * 0.4);
      state.targetOpacity = Math.max(baseDim, state.targetOpacity);
    });
  }
  
  // ========================================
  // DECAY & VISUAL UPDATE
  // ========================================
  bars.each(function(d) {
    const state = barStates.get(d.pathway);
    const el = d3.select(this);
    
    // Natural decay with tiny organic randomness
    state.excitation *= 0.985 + Math.random() * 0.003;
    
    if (state.excitation < 0.01) state.excitation = 0;
    
    // If cursor not active, restore opacity
    if (!cursorField.active) {
      state.targetOpacity = 1;
    }
    
    // Growth from excitation (small bars grow more)
    const growth = state.excitation * d.growthBoost;
    const targetScaleX = 1 + growth * 2.0;
    const targetScaleY = 1 + growth * 0.35;
    
    // Lerp toward targets
    const growing = targetScaleY > state.currentScaleY;
    const lerp = growing ? bloomLerp : decayLerp;
    
    state.currentScaleX += (targetScaleX - state.currentScaleX) * lerp;
    state.currentScaleY += (targetScaleY - state.currentScaleY) * lerp;
    state.currentOpacity += (state.targetOpacity - state.currentOpacity) * 0.06;
    
    el.attr('transform', `scale(${state.currentScaleX}, ${state.currentScaleY})`);
    el.style('opacity', state.currentOpacity);
    
    // ========================================
    // BREATHING - Subtle life modulation
    // ========================================
    if (!cursorField.active) {
      state.ripplePhase += state.rippleDrift * 0.001;
      
      const breath = 
        Math.sin(globalTime * 0.28 + state.ripplePhase) * 0.42 +
        Math.sin(globalTime * 0.09 + state.ripplePhase * 2.1) * 0.08 +
        0.5;
      
      const midPos = 30 + breath * 40;
      const c = d.baseColor;
      const pulse = Math.sin(globalTime * 0.22 + state.ripplePhase) * 4 * audioGlow;
      
      const grad = d3.select(`#grad-${d.index}`);
      grad.select('.stop-mid')
        .attr('offset', `${midPos}%`)
        .attr('stop-color', `hsl(${c.h}, ${c.s}%, ${c.l + 8 + pulse}%)`);
    }
  });
  
  // Update voices from excitation peaks
  updateVoicesFromField();
}

// ============================================================
// ZOOM
// ============================================================
function zoomed(event) {
  currentTransform = event.transform;
  xScale = currentTransform.rescaleX(xScaleOriginal);
  
  const domain = xScale.domain();
  const ticks = [100, 200, 300, 500, 750, 1000, 1500, 2000, 3000, 5000]
    .filter(t => t >= domain[0] && t <= domain[1]);
  
  svg.select('.x-axis').call(d3.axisBottom(xScale).tickValues(ticks)
    .tickFormat(d => d >= 1000 ? (d/1000) + 'k' : d));
  
  bars.attr('x', d => xScale(d.frequency) - widthScale(d.amp) / 2);
  
  document.getElementById('zoomReset').classList.toggle('visible', currentTransform.k > 1);
}

function resetZoom() {
  d3.select('#chart').transition().duration(400).call(zoom.transform, d3.zoomIdentity);
}

// ============================================================
// BUILD
// ============================================================
function animateBuild() {
  const sorted = [...pathwayData].sort((a, b) => a.complexity - b.complexity);
  const n = sorted.length;
  const totalTime = buildBuffer ? buildBuffer.duration * 1000 : 4000;
  
  sorted.forEach((d, i) => {
    const delay = Math.pow(i / n, 3) * totalTime;
    
    setTimeout(() => {
      bars.filter(dd => dd === d)
        .transition()
        .duration(600)
        .ease(d3.easeCubicOut)
        .attr('y', yScale(d.amp))
        .attr('height', Math.max(1, height - yScale(d.amp)));
      
      document.getElementById('progressBar').style.width = `${(i + 1) / n * 100}%`;
    }, delay);
  });
}

// ============================================================
// COLOR UPDATE
// ============================================================
function updateColors() {
  const maxFreq = Math.max(...pathwayData.map(d => d.frequency));
  const maxComplex = Math.max(...pathwayData.map(d => d.complexity));
  
  pathwayData.forEach(d => {
    d.baseColor = getBlendedColor(d, colorMode, maxFreq, maxComplex);
    const c = d.baseColor;
    const grad = d3.select(`#grad-${d.index}`);
    grad.select('.stop-bot').attr('stop-color', `hsl(${c.h}, ${c.s}%, ${c.l}%)`);
    grad.select('.stop-mid').attr('stop-color', `hsl(${c.h}, ${c.s}%, ${c.l + 8}%)`);
    grad.select('.stop-top').attr('stop-color', `hsl(${c.h}, ${c.s}%, ${c.l}%)`);
  });
}

document.getElementById('colorMode').addEventListener('change', (e) => {
  colorMode = e.target.value;
  updateColors();
});

document.getElementById('scaleToggle').addEventListener('change', (e) => {
  const useSymlog = e.target.checked;
  const maxAmp = Math.max(...pathwayData.map(d => d.amp));
  
  yScale = useSymlog
    ? d3.scaleSymlog().constant(0.0001).domain([0, maxAmp * 1.1]).range([height, 0])
    : d3.scaleLinear().domain([0, maxAmp * 1.1]).range([height, 0]);
  
  svg.select('.y-axis').transition().duration(400)
    .call(d3.axisLeft(yScale).ticks(3).tickFormat(d3.format('.2f')));
  
  bars.transition().duration(400)
    .attr('y', d => yScale(d.amp))
    .attr('height', d => Math.max(1, height - yScale(d.amp)));
});

// ============================================================
// START
// ============================================================
document.getElementById('overlay').addEventListener('click', async () => {
  document.getElementById('overlay').classList.add('hidden');
  await initAudio();
  playBuild();
  animateBuild();
});

loadData();
</script>
</body>
</html>