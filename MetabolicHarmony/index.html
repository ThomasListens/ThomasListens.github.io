<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metabolic Harmony | Gut Microbiome Sonification</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Noto+Naskh+Arabic:wght@400;500;600;700&family=Noto+Serif:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body { font-family: 'Noto Serif', 'Noto Naskh Arabic', Georgia, serif; background: #fafafa; color: #1a1a1a; line-height: 1.5; }
        .app-container { display: grid; grid-template-columns: 340px 1fr; height: 100vh; }
        .sidebar { background: #fff; border-right: 1px solid #e5e5e5; padding: 12px 14px; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; }
.app-title {
    font-size: 1.8rem;
    font-weight: 600;
    line-height: 1.2;
    text-align: center;
}

.app-title .outline {
    color: transparent;
    -webkit-text-stroke: 1px #111;
}
.app-title .subtle {
    text-shadow: inset 0.5px 0.5px 0 #fff;
}
.app-title .solid {
    color: #111;
}
   .app-title .metabolic {
       font-weight: 700;  /* heavier to compensate for outline */
   }
.app-title .harmony {
    color: #111;
}
.app-subtitle .hollow {
    color: #e2e2e2;
    -webkit-text-stroke: 0.3px #000000;
}
        .app-subtitle { font-size: 1rem; color: #666; font-weight: 400; margin-top: 2px; text-align: center; }
        .title-section { padding-bottom: 8px; border-bottom: 3px solid #e5e5e5; }
        .nav-btn-text { font-size: 1rem; display: block; text-align: left; line-height: 1.2; }
        .nav-btn-title { font-weight: 600; letter-spacing: .07ch; }
        .nav-btn-title::after {
  content: '';
  width: 86px;
  height: 1px;
  background: #888;
  margin-left: 9px;
  display: inline-block;
  vertical-align: middle;
}
        .nav-btn-sub { display: block; font-size: 0.68rem; color: #777; font-weight: 400; }
        .nav-btn.active .nav-btn-sub { color: rgba(255, 255, 255, 0.9); }
        .nav-btn.active .nav-btn-title { color: #fff; }
        .nav-section h3, .controls-section h3 { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.08em; color: #999; margin-bottom: 6px; font-weight: 600; text-align: center; }
        .nav-tagline { 
            font-family: 'Noto Serif', Georgia, serif;
            font-weight: 400; 
            font-style: italic; 
            color: #777; 
            text-transform: none; 
            letter-spacing: 0.22em;
            font-size: 0.78rem;
            margin-bottom: 6px;
            text-align: center;
            padding: 2px 0;
        }
        .nav-buttons { display: flex; flex-direction: column; gap: 5px; }
        .nav-btn { display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: #f8f8f8; border: 1px solid #e0e0e0; border-radius: 5px; cursor: pointer; transition: all 0.2s; font-size: 1.2rem; color: #333; }
        .nav-btn:hover { background: #f0f0f0; border-color: #ccc; }
        .nav-btn.active { background: #111; color: #fff; border-color: #111; }
        .nav-btn .indicator { width: 8px; height: 8px; border-radius: 50%; background: #ddd; flex-shrink: 0; }
        .nav-btn.active .indicator { background: #22c55e; }
        
/* Key Findings Section */
.key-findings-section { margin-top: 8px; padding: 10px; background: #f8f8f8; border: 1px solid #e5e5e5; border-radius: 8px; opacity: 0.6; transition: opacity 0.3s; }
.key-findings-section.enabled { opacity: 1; background: #fff; }
.key-findings-section h4 { font-size: 0.62rem; text-transform: uppercase; letter-spacing: 0.06em; color: #888; margin-bottom: 8px; font-weight: 600; display: flex; align-items: center; gap: 6px; }
.key-findings-section h4 a { color: #3b82f6; text-decoration: none; }
.key-findings-section h4 a:hover { text-decoration: underline; }
.findings-status { font-size: 0.55rem; color: #aaa; font-weight: 400; text-transform: none; letter-spacing: 0; }
.key-findings-section.enabled .findings-status { display: none; }

/* Key Findings Grid */
.key-findings-grid { display: flex; flex-direction: column; gap: 3px; }
.key-finding-btn { display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: #fff; border: 1px solid #e5e5e5; border-radius: 5px; cursor: pointer; text-align: left; transition: all 0.12s ease; }
.key-finding-btn.disabled { cursor: not-allowed; opacity: 0.5; background: #fafafa; }
.key-finding-btn:not(.disabled):hover { background: #f8f8f8; border-color: #d0d0d0; }
.key-finding-btn.active { background: #fff; border-color: #999; border-width: 1.5px; }
.key-finding-btn .finding-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }
.key-finding-btn .finding-text { display: flex; align-items: baseline; gap: 8px; }
.key-finding-btn .finding-title { font-size: 0.73rem; font-weight: 600; color: #333; }
.key-finding-btn .finding-expansion { display: block; font-size: 0.58rem; font-weight: 400; color: #888; letter-spacing: 0.02em; margin-top: 1px; }
.key-finding-btn .finding-direction { font-size: 0.65rem; color: #999; font-weight: 400; }
        
        /* Special button styling */
        .key-finding-btn.kynurenine-btn:not(.disabled) { border-color: #8b5cf6; background: #faf5ff; }
        .key-finding-btn.kynurenine-btn.active { border-color: #7c3aed; background: #f3e8ff; }
        .key-finding-btn.energy-btn:not(.disabled) { border-color: #22c55e; background: #f0fdf4; }
        .key-finding-btn.energy-btn.active { border-color: #16a34a; background: #dcfce7; }
        .key-finding-btn.scfa-btn:not(.disabled) { border-color: #06b6d4; background: #ecfeff; }
        .key-finding-btn.scfa-btn.active { border-color: #0891b2; background: #cffafe; }
        
        .findings-citation { font-size: 0.55rem; color: #999; margin-top: 6px; }
        .findings-citation a { color: #3b82f6; text-decoration: none; }
        .findings-citation a:hover { text-decoration: underline; }
        
        /* MS Compare Button special styling */
        .ms-compare-btn { border-color: #a855f7; }
        .ms-compare-btn:hover { background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%); }
        .ms-compare-btn.active { 
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%); 
            border-color: #5b21b6; 
            color: #fff;
        }
        .ms-compare-btn.active .nav-btn-title { color: #fff; }
        .ms-compare-btn.active .nav-btn-sub { color: rgba(255, 255, 255, 0.9); }
        .ms-compare-btn .indicator { background: #a855f7; }
        .ms-compare-btn.active .indicator { background: #22c55e; }
        
        /* Dynamic Study Info Panel (replaces docs-panel when finding active) */
        .study-info-panel { padding: 12px 16px; background: #fff; border: 1px solid #e5e5e5; border-radius: 6px; }
        .study-info-panel .panel-header { font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.08em; color: #999; margin-bottom: 8px; font-weight: 600; display: flex; justify-content: space-between; align-items: center; }
        .study-info-panel .panel-header .close-btn { background: none; border: none; font-size: 1rem; color: #999; cursor: pointer; padding: 0 4px; }
        .study-info-panel .panel-header .close-btn:hover { color: #333; }
        .study-info-panel .finding-title-text { font-size: 0.9rem; font-weight: 600; color: #111; margin-bottom: 3px; }
        .study-info-panel .finding-subtitle { font-size: 0.7rem; color: #666; margin-bottom: 8px; font-style: italic; }
        .study-info-panel .finding-summary { font-size: 0.68rem; color: #444; line-height: 1.45; margin-bottom: 8px; }
        .study-info-panel .key-findings-list { list-style: none; padding: 0; margin: 0 0 8px 0; }
        .study-info-panel .key-findings-list li { font-size: 0.65rem; color: #555; padding: 3px 0; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; }
        .study-info-panel .key-findings-list li:last-child { border-bottom: none; }
        .study-info-panel .key-findings-list .value { font-weight: 600; color: #333; }
        .study-info-panel .key-findings-list .note { font-size: 0.55rem; color: #888; font-style: italic; margin-left: 4px; }
        .study-info-panel .citation { font-size: 0.58rem; color: #888; border-top: 1px solid #e5e5e5; padding-top: 6px; margin-top: 6px; }
        .study-info-panel .citation a { color: #3b82f6; text-decoration: none; }
        .study-info-panel .citation a:hover { text-decoration: underline; }
        
        .controls-section { margin-top: 8px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: flex; justify-content: space-between; align-items: baseline; font-size: 0.65rem; color: #666; margin-bottom: 4px; font-weight: 500; }
        .control-group label .hint { font-weight: 400; color: #999; font-size: 0.55rem; }
        .slider-row { display: flex; align-items: center; gap: 8px; }
        input[type="range"] { flex: 1; height: 4px; -webkit-appearance: none; background: #e0e0e0; border-radius: 2px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #333; border-radius: 50%; cursor: pointer; }
        .slider-value { font-size: 0.65rem; color: #333; min-width: 38px; text-align: right; font-variant-numeric: tabular-nums; }
        
        /* Subcategory Faders - Compact: [dot+label btn] [slider] - click to sequence */
        .subcategory-section { margin-top: 2px; min-height: 180px; }
        .subcategory-header { font-size: 0.6rem; color: #666; margin-bottom: 4px; display: flex; align-items: center; gap: 4px; }
        .subcategory-header .cat-indicator { width: 5px; height: 5px; border-radius: 50%; }
        .subcat-nav-btn {
            width: 16px;
            height: 16px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 3px;
            color: #888;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            padding: 0;
            line-height: 1;
        }
        .subcat-nav-btn:hover {
            background: #eee;
            border-color: #ccc;
            color: #555;
        }
        .subcat-nav-btn:active {
            background: #e0e0e0;
        }
        .stop-all-btn {
            width: 16px;
            height: 16px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 3px;
            color: #999;
            font-size: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            opacity: 0.5;
        }
        .stop-all-btn:hover {
            background: #ef4444;
            border-color: #dc2626;
            color: #fff;
            opacity: 1;
        }
        .stop-all-btn.has-active {
            opacity: 1;
            background: #fef2f2;
            border-color: #fca5a5;
            color: #ef4444;
        }
        
        .solo-all-btn {
            background: transparent;
            border: 1px solid #22c55e;
            color: #22c55e;
            width: 16px;
            height: 16px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 9px;
            font-weight: bold;
            margin-left: auto;
            margin-right: 4px;
            opacity: 0.5;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .solo-all-btn:hover {
            opacity: 1;
            background: rgba(34, 197, 94, 0.1);
        }
        .solo-all-btn.active {
            background: #22c55e;
            color: white;
            opacity: 1;
        }
        
        .subcategory-faders { 
            display: flex; 
            flex-direction: column; 
            gap: 3px; 
            padding-left: 8px; 
            border-left: 2px solid #22c55e; 
            transition: border-color 0.3s; 
            max-height: 150px;
            overflow-y: auto;
        }
        .subcategory-fader { 
            display: grid; 
            grid-template-columns: 110px 1fr; 
            align-items: center; 
            gap: 6px; 
            height: 22px;
        }

        .subcat-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: #fafafa;
            border: 1px solid #e5e5e5;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
            overflow: hidden;
            --cat-color: #22c55e;  /* Default, set dynamically */
            --cat-color-light: #dcfce7;
        }

        .subcat-btn:hover {
            background: #f0f0f0;
            border-color: #d0d0d0;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }

        .subcat-btn:active {
            background: #e8e8e8;
            transform: translateY(1px);
        }

        /* Active/cycling state - fills with category color */
        .subcat-btn.cycling {
            background: var(--cat-color-light);
            border-color: var(--cat-color);
            box-shadow: 0 0 0 1px var(--cat-color);
        }
        
        .subcat-btn.cycling .label {
            color: #222;
            font-weight: 600;
        }

        .subcat-btn .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
            transition: opacity 0.3s, transform 0.15s;
        }

        .subcat-btn:hover .dot {
            opacity: 0.8;
        }

        /* Tempo-synced pulse animation */
        .subcat-btn.cycling .dot {
            animation: tempo-pulse var(--pulse-duration, 350ms) ease-in-out infinite;
        }

        @keyframes tempo-pulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.4); opacity: 1; }
        }

        .subcat-btn .label {
            font-size: 0.55rem;
            color: #444;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .subcategory-fader input[type="range"] { 
            width: 100%;
            height: 3px;
            -webkit-appearance: none;
            appearance: none;
            background: #e8e8e8;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        .subcategory-fader input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 10px;
            background: #555;
            border-radius: 50%;
            cursor: pointer;
        }
        .subcategory-fader input[type="range"]::-moz-range-thumb {
            width: 10px;
            height: 10px;
            background: #555;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .main-content { display: flex; flex-direction: column; height: 100vh; }
        .viz-container { 
            height: 60vh; 
            min-height: 150px; 
            position: relative; 
            background: #fff; 
            border-bottom: 1px solid #e5e5e5; 
            flex-shrink: 0; 
            transition: background-color 0.4s ease;
        }
        .viz-container.dark-mode {
            background: #111;
            border-bottom-color: #333;
        }
        .viz-container.mode-transition {
            animation: mode-flash 0.3s ease-out;
        }
        @keyframes mode-flash {
            0% { filter: brightness(1); }
            30% { filter: brightness(0.7); }
            100% { filter: brightness(1); }
        }
        .viz-container::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(196, 196, 196, 0.9); z-index: 1; pointer-events: none; opacity: 1; transition: opacity 0.3s ease; }
        .viz-container.active::before { opacity: 0; }
        .viz-container.dark-mode::before { background: rgba(30, 30, 30, 0.9); }
        .viz-container.dark-mode .axis-label { color: #666; }
        .viz-container.dark-mode .zoom-hint { color: #555; }
        #spectrumCanvas { width: 100%; height: 100%; display: block; cursor: grab; }
        #spectrumCanvas:active { cursor: grabbing; }
        .axis-label { position: absolute; font-size: 0.6rem; color: #999; text-transform: uppercase; letter-spacing: 0.1em; }
        .axis-label.x-axis { bottom: 6px; left: 50%; transform: translateX(-50%); }
        .axis-label.y-axis { left: 4px; top: 50%; transform: translateY(-50%) rotate(-90deg); transform-origin: center; }
        .play-btn { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 70px; height: 70px; background: #fff; border: 2px solid #333; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 2; }
        .play-btn:hover { transform: translate(-50%, -50%) scale(1.05); box-shadow: 0 4px 16px rgba(0,0,0,0.15); }
        .play-btn svg { width: 28px; height: 28px; fill: #333; }
        .play-btn.loading { opacity: 0.5; cursor: wait; }
        .play-btn.loading svg { animation: pulse-loading 1s ease-in-out infinite; }
        @keyframes pulse-loading { 0%, 100% { opacity: 0.4; } 50% { opacity: 1; } }
        .play-btn.playing { top: auto; bottom: 12px; left: 12px; transform: none; width: 44px; height: 44px; background: #111; border-color: #111; }
        .play-btn.playing:hover { transform: scale(1.05); }
        .play-btn.playing svg { width: 18px; height: 18px; fill: #fff; }
        .reset-zoom-btn { position: absolute; top: 10px; right: 10px; padding: 5px 10px; background: #111; color: #fff; border: none; border-radius: 4px; font-size: 0.65rem; cursor: pointer; z-index: 2; opacity: 0; transition: opacity 0.2s; text-transform: uppercase; letter-spacing: 0.05em; }
        .reset-zoom-btn.visible { opacity: 1; }
        .reset-zoom-btn:hover { background: #333; }
        .zoom-hint { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 0.6rem; color: #999; z-index: 2; pointer-events: none; opacity: 0; transition: opacity 0.3s; }
        .viz-container.active .zoom-hint { opacity: 1; }
        /* ═══════════════════════════════════════════════════════════════════
           BOTTOM SECTION - 3-tier horizontal layout with audio sidebar
           ═══════════════════════════════════════════════════════════════════ */
        .bottom-section { display: flex; flex: 1; min-height: 0; }
        
        /* Main content area (3 tiers stacked) */
        .bottom-main { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        
        /* Tier 1: Selected Pathway (top, stable layout) */
        .tier-pathway { 
            background: #fff; 
            border-bottom: 1px solid #e5e5e5; 
            padding: 10px 16px;
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 14px;
            flex-shrink: 0;
            min-height: 48px;
        }
        .pathway-identity-box {
            display: flex;
            align-items: stretch;
            background: #f0fdf4;  /* Default energy light green, updated dynamically */
            border-radius: 5px;
            overflow: hidden;
            min-width: 200px;
            max-width: 280px;
        }
        .pathway-identity-box.energy { background: #f0fdf4; }
        .pathway-identity-box.biosynthesis { background: #eff6ff; }
        .pathway-identity-box.degradation { background: #fef2f2; }
        .pathway-identity-box.salvage { background: #fefce8; }
        .pathway-identity-box.other { background: #f9fafb; }
        .pathway-identity-box.superpathways { background: #faf5ff; }
        
        .pathway-id { 
            font-family: 'JetBrains Mono', 'Consolas', monospace; 
            font-size: 0.72rem; 
            font-weight: 700;
            color: #fff; 
            background: #22c55e;
            padding: 6px 10px; 
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 90px;
            max-width: 140px;
        }
        .pathway-id.energy { background: #22c55e; }
        .pathway-id.biosynthesis { background: #3b82f6; }
        .pathway-id.degradation { background: #ef4444; }
        .pathway-id.salvage { background: #ca8a04; }
        .pathway-id.other { background: #6b7280; }
        .pathway-id.superpathways { background: #8b5cf6; }
        
        /* Dynamic font size for long IDs */
        .pathway-id.long-id { font-size: 0.6rem; }
        .pathway-id.very-long-id { font-size: 0.52rem; }
        
        .pathway-cat-info {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 1px;
            padding: 4px 10px;
        }
        .pathway-cat-info .cat-label {
            font-size: 0.65rem;
            font-weight: 600;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }
        .pathway-cat-info .subcat-label {
            font-size: 0.58rem;
            color: #666;
        }
        
        .pathway-name { 
            font-size: 0.85rem; 
            color: #333; 
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: 400;
        }
        .pathway-metrics {
            display: flex;
            align-items: center;
            gap: 14px;
            flex-shrink: 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.68rem;
        }
        .pathway-metric {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 1px;
        }
        .pathway-metric .value { 
            color: #333; 
            font-weight: 500; 
            font-size: 0.75rem;
        }
        .pathway-metric .label { 
            color: #999; 
            font-size: 0.55rem; 
            text-transform: uppercase; 
            letter-spacing: 0.03em; 
        }
        .category-badge { 
            display: inline-block; 
            padding: 3px 10px; 
            border-radius: 3px; 
            font-size: 0.7rem; 
            font-weight: 600; 
        }
        .category-badge.energy { background: #dcfce7; color: #166534; }
        .category-badge.biosynthesis { background: #dbeafe; color: #1e40af; }
        .category-badge.degradation { background: #fee2e2; color: #991b1b; }
        .category-badge.salvage { background: #fef9c3; color: #854d0e; }
        .category-badge.other, .category-badge.superpathways { background: #f3f4f6; color: #374151; }
        
        /* Tier 2: Main Summary (middle, flexible) */
        /* Healthy content - two column split */
        .healthy-two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .healthy-about, .healthy-pathway-detail {
            min-width: 0;
        }
        .healthy-header {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #999;
            margin-bottom: 8px;
            font-weight: 600;
        }
        .healthy-description {
            font-size: 0.78rem;
            color: #333;
            line-height: 1.5;
            margin: 0 0 8px 0;
        }
        .healthy-mode {
            font-size: 0.72rem;
            color: #555;
            line-height: 1.45;
            margin: 0 0 4px 0;
        }
        .healthy-mode strong {
            color: #333;
        }
        
        /* === TIER SUMMARY - Main Content Area === */
        .tier-summary {
            flex: 1;
            padding: 14px 20px;
            overflow: hidden;
            background: #fff;
            display: flex;
            flex-direction: column;
        }
        
        /* Pathway Summary Section - fixed height, top half */
        .pathway-summary-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding-bottom: 12px;
            border-bottom: 1px solid #eee;
            min-height: 0;
        }
        .pathway-summary-text {
            font-size: 1rem;
            color: #333;
            line-height: 1.5;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            flex-shrink: 0;
        }
        .pathway-summary-link {
            display: inline-block;
            margin-top: 8px;
            font-size: 0.85rem;
            color: #3b82f6;
            text-decoration: none;
            font-weight: 500;
        }
        .pathway-summary-link:hover {
            text-decoration: underline;
        }
        
        /* Documentation Section - bottom half */
        .docs-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            padding-top: 12px;
            min-height: 0;
            overflow-y: auto;
        }
        .docs-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #999;
            margin-bottom: 8px;
            font-weight: 600;
            flex-shrink: 0;
            font-family: 'JetBrains Mono', monospace;
        }
        .docs-text {
            font-size: 0.88rem;
            color: #444;
            line-height: 1.6;
        }
        .docs-text p {
            margin: 0 0 8px 0;
        }
        .docs-text p.docs-cta {
            font-family: 'Noto Serif', Georgia, serif;
            font-style: italic;
            font-size: 0.84rem;
            color: #777;
            margin-top: 12px;
            letter-spacing: 0.06em;
        }
        .docs-text strong {
            color: #222;
            font-weight: 600;
        }
        .docs-text a.docs-link {
            color: #2563eb;
            text-decoration: none;
            border-bottom: 1px dotted #93c5fd;
            transition: all 0.15s ease;
        }
        .docs-text a.docs-link:hover {
            color: #1d4ed8;
            border-bottom-color: #2563eb;
        }
        .docs-indent {
            display: block;
            margin-left: 16px;
            margin-top: 10px;
            padding-left: 10px;
            border-left: 2px solid #e5e5e5;
        }
        .docs-indent + .docs-indent {
            margin-top: 8px;
        }
        
        /* Finding Content - takes full space */
        #findingContent {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .finding-header {
            display: flex;
            align-items: baseline;
            gap: 10px;
            margin-bottom: 10px;
        }
        .finding-title-block {
            display: flex;
            flex-direction: column;
        }
        .finding-title {
            font-size: 1.15rem;
            font-weight: 600;
            color: #333;
        }
        #findingContent .finding-expansion {
            font-size: 0.7rem;
            color: #888;
            font-weight: 400;
            letter-spacing: 0.01em;
            margin-top: -1px;
        }
        .finding-subtitle {
            font-size: 0.9rem;
            color: #666;
            font-style: italic;
        }
        .finding-header .close-btn {
            margin-left: auto;
        }
        
        .finding-quote {
            background: #f8f9fa;
            border-left: 3px solid #8b5cf6;
            padding: 10px 14px;
            margin: 0 0 12px 0;
            border-radius: 0 6px 6px 0;
        }
        .finding-quote p {
            font-size: 0.95rem;
            font-style: italic;
            color: #333;
            line-height: 1.5;
            margin: 0 0 4px 0;
        }
        .finding-quote cite {
            font-size: 0.75rem;
            color: #666;
            font-style: normal;
        }
        
        .finding-evidence, .finding-pathways {
            margin-bottom: 10px;
        }
        .evidence-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #888;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        .metabolite-chips, .pathway-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .metabolite-chip {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            background: #f5f5f5;
            border-radius: 14px;
            font-size: 0.8rem;
        }
        .metabolite-chip .dir {
            font-weight: 700;
        }
        .metabolite-chip .dir.depleted { color: #dc2626; }
        .metabolite-chip .dir.elevated { color: #16a34a; }
        .metabolite-chip .p-val {
            color: #888;
            font-size: 0.7rem;
        }
        
        .pathway-chip {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            background: #fefce8;
            border: 1px solid #fef08a;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }
        .pathway-chip .dir {
            font-weight: 700;
        }
        .pathway-chip .dir.depleted { color: #dc2626; }
        .pathway-chip .dir.elevated { color: #16a34a; }
        
        .finding-clinical {
            background: #f0fdf4;
            border-left: 3px solid #22c55e;
            padding: 8px 12px;
            border-radius: 0 4px 4px 0;
            margin-top: auto;
        }
        .finding-clinical p {
            font-size: 0.85rem;
            color: #166534;
            line-height: 1.45;
            margin: 0;
        }
        
        /* When finding is active, hide refs */
        .finding-active .tier-refs {
            display: none;
        }
        
        /* References Footer */
        .tier-refs {
            padding: 6px 16px;
            background: #fafafa;
            border-top: 1px solid #eee;
            font-size: 0.75rem;
            color: #888;
            text-align: center;
        }
        .tier-refs a {
            color: #3b82f6;
            text-decoration: none;
        }
        .tier-refs a:hover {
            text-decoration: underline;
        }
        
        /* Close button */
        .close-btn {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #999;
            cursor: pointer;
            padding: 0 4px;
        }
        .close-btn:hover {
            color: #333;
        }
        
        .summary-header {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #999;
            margin-bottom: 8px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .summary-header .close-btn {
            background: none;
            border: none;
            font-size: 1rem;
            color: #999;
            cursor: pointer;
            padding: 0 4px;
        }
        .summary-header .close-btn:hover { color: #333; }
        .summary-title {
            font-size: 1rem;
            font-weight: 600;
            color: #111;
            margin-bottom: 4px;
        }
        .summary-subtitle {
            font-size: 0.75rem;
            color: #666;
            font-style: italic;
            margin-bottom: 10px;
        }
        .summary-text {
            font-size: 0.78rem;
            color: #333;
            line-height: 1.55;
        }
        
        /* Enhanced Finding Display */
        .finding-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        .finding-quote {
            background: linear-gradient(135deg, #f8f9fa 0%, #f0f4f8 100%);
            border-left: 3px solid var(--finding-color, #8b5cf6);
            padding: 10px 14px;
            margin: 0 0 12px 0;
            border-radius: 0 6px 6px 0;
        }
        .finding-quote p {
            font-size: 0.78rem;
            font-style: italic;
            color: #333;
            line-height: 1.5;
            margin: 0 0 4px 0;
        }
        .finding-quote cite {
            font-size: 0.65rem;
            color: #666;
            font-style: normal;
        }
        .finding-quote cite a {
            color: #3b82f6;
            text-decoration: none;
        }
        .finding-quote cite a:hover { text-decoration: underline; }
        
        .finding-section {
            margin-bottom: 12px;
        }
        .section-label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #888;
            margin-bottom: 6px;
            font-weight: 600;
        }
        
        /* Metabolite chips - horizontal flow */
        .metabolite-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .metabolite-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: #f5f5f5;
            border-radius: 20px;
            font-size: 0.72rem;
        }
        .metabolite-chip .name {
            color: #333;
        }
        .metabolite-chip .dir {
            font-weight: 700;
            font-size: 0.85rem;
        }
        .metabolite-chip .dir.depleted { color: #dc2626; }
        .metabolite-chip .dir.elevated { color: #16a34a; }
        .metabolite-chip .p-val {
            color: #888;
            font-size: 0.65rem;
        }
        
        /* Pathway list - clean inline */
        .pathway-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .pathway-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 5px 10px;
            background: #fefce8;
            border: 1px solid #fef08a;
            border-radius: 4px;
            font-size: 0.72rem;
        }
        .pathway-chip .pathway-id {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.68rem;
            color: #713f12;
            font-weight: 600;
        }
        .pathway-chip .pathway-dir {
            font-weight: 700;
            font-size: 0.85rem;
        }
        .pathway-chip .pathway-dir.depleted { color: #dc2626; }
        .pathway-chip .pathway-dir.elevated { color: #16a34a; }
        
        /* Clinical note */
        .finding-clinical {
            background: #f0fdf4;
            padding: 8px 10px;
            border-radius: 4px;
            border-left: 3px solid #22c55e;
        }
        .finding-clinical p {
            font-size: 0.72rem;
            color: #166534;
            line-height: 1.45;
            margin: 0;
        }
        .finding-citation {
            font-size: 0.68rem;
            color: #888;
            text-align: right;
            padding-top: 6px;
            border-top: 1px solid #eee;
        }
        .finding-citation a {
            color: #3b82f6;
            text-decoration: none;
        }
        .finding-citation a:hover {
            text-decoration: underline;
        }
        
        .summary-findings {
            margin-top: 12px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 6px;
        }
        .finding-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: #fff;
            border-radius: 3px;
            font-size: 0.7rem;
        }
        .finding-item .text { color: #555; }
        .finding-item .value { font-weight: 600; color: #111; }
        .finding-item .note { font-size: 0.6rem; color: #888; margin-left: 4px; }

        .learn-more {
  margin-left: 4px;
  font-size: 0.8rem;
  color: #3b82f6;
  text-decoration: none;
  white-space: nowrap;
}

.learn-more:hover {
  text-decoration: underline;
}
        
        .docs-intro {
            font-size: 0.72rem;
            color: #555;
            line-height: 1.45;
            margin-bottom: 6px;
            margin-top: 0;
        }
        .docs-intro a {
            color: #3b82f6;
            text-decoration: none;
        }
        .docs-intro a:hover { text-decoration: underline; }
        
        /* Pathway detail panel */
        .pathway-detail-content {
            font-size: 0.72rem;
            color: #555;
            line-height: 1.45;
        }
        .pathway-detail-placeholder {
            color: #999;
            font-style: italic;
            margin: 0;
        }
        .pathway-detail-id {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.68rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }
        .pathway-detail-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }
        .pathway-detail-summary {
            color: #555;
            margin-bottom: 6px;
        }
        .pathway-detail-link {
            font-size: 0.65rem;
        }
        .pathway-detail-link a {
            color: #3b82f6;
            text-decoration: none;
        }
        .pathway-detail-link a:hover { text-decoration: underline; }
        
        .docs-references {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            padding-top: 8px;
            border-top: 1px solid #eee;
        }
        .docs-references a {
            display: flex;
            flex-direction: column;
            text-decoration: none;
            text-align: center;
            flex: 1;
        }
        .docs-references .ref-name {
            font-size: 0.68rem;
            font-weight: 600;
            color: #3b82f6;
        }
        .docs-references .ref-desc {
            font-size: 0.58rem;
            color: #888;
            margin-top: 1px;
        }
        .docs-references a:hover .ref-name {
            text-decoration: underline;
        }
        
        /* Inline references */
        .docs-references-inline {
            font-size: 0.65rem;
            color: #777;
            margin-top: 6px;
        }
        .docs-references-inline a {
            color: #3b82f6;
            text-decoration: none;
            font-weight: 500;
        }
        .docs-references-inline a:hover {
            text-decoration: underline;
        }
        .docs-references-inline .ref-dot {
            color: #bbb;
            margin: 0 2px;
        }
        .docs-references-inline .ref-sep {
            color: #ddd;
            margin: 0 8px;
        }
        
        /* Audio sidebar (right side) */
        .bottom-audio { 
            width: 160px; 
            background: #fff; 
            display: flex; 
            flex-direction: column; 
            flex-shrink: 0;
            border-left: 1px solid #e5e5e5;
        }
        .scope-section { 
            padding: 6px; 
            border-bottom: 1px solid #e5e5e5;
        }
        .oscilloscope { 
            width: 100%; 
            height: 80px; 
            background: #111; 
            border-radius: 4px; 
        }
        #scopeCanvas { width: 100%; height: 100%; }
        .audio-section { 
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        .audio-item {
            padding: 10px 12px;
            text-align: center;
            border-bottom: 1px solid #e5e5e5;
        }
        .audio-item:last-child {
            border-bottom: none;
        }
        .audio-item .value { 
            font-size: 1.2rem; 
            font-weight: 600; 
            color: #333;
            font-family: 'JetBrains Mono', monospace;
        }
        .audio-item .label { 
            font-size: 0.55rem; 
            color: #888; 
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 2px;
        }
        .audio-item.ratio-main .value {
            font-size: 1.6rem;
            color: #111;
        }
        .audio-item.consonance {
            background: #f9fafb;
        }
        .audio-item.consonance .value {
            font-size: 1.1rem;
        }
        .signature { 
            padding: 10px 8px; 
            font-family: 'Noto Serif', Georgia, serif;
            font-size: 0.75rem; 
            color: #888; 
            font-style: italic; 
            text-align: center; 
            border-top: 1px solid #eee;
            margin-top: auto;
            letter-spacing: 0.1em;
        }
        .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.35);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        }

        .modal-overlay.active {
  display: flex;         
}

.modal {
  background: #fff;
  width: min(720px, 90vw);
  max-height: 85vh;
  border-radius: 8px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.25);
  display: flex;
  flex-direction: column;
}

.modal-header {
  padding: 12px 16px;
  border-bottom: 1px solid #e5e5e5;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header h2 {
  font-size: 1.1rem;
  font-weight: 600;
}

.modal-close {
  background: none;
  border: none;
  font-size: 1.4rem;
  cursor: pointer;
  color: #666;
}

.modal-content {
  padding: 16px;
  overflow-y: auto;
}

.methods-text {
  font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
  font-size: 0.85rem;
  line-height: 1.5;
  white-space: pre-wrap;
  color: #222;
}

/* ═══════════════════════════════════════════════════════════════════════════════
   v4.0 ADDITIONS - Mode Toggle, Mute Buttons, Subcategory Hints
   ═══════════════════════════════════════════════════════════════════════════════ */

/* Mode Toggle Section */
.mode-section {
    padding: 4px 0 10px 0;
    border-bottom: 1px solid #e5e5e5;
}

.mode-toggle {
    display: flex;
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #222;
}

.mode-btn {
    flex: 1;
    padding: 10px 12px;
    border: none;
    cursor: pointer;
    font-size: 0.75rem;
    font-weight: 500;
    transition: all 0.25s ease;
    text-align: center;
}

.mode-btn[data-mode="composed"] {
    background: #fff;
    color: #222;
}

.mode-btn[data-mode="consonance"] {
    background: #111;
    color: #fff;
}

.mode-btn[data-mode="composed"].active {
    background: #fff;
    color: #111;
    font-weight: 700;
}

.mode-btn[data-mode="consonance"].active {
    background: #000;
    color: #fff;
    font-weight: 700;
}

.mode-btn:not(.active) {
    opacity: 0.85;
}

.mode-btn:not(.active):hover {
    opacity: 0.9;
}

.mode-btn .mode-sub {
    display: block;
    font-size: 0.55rem;
    font-weight: 400;
    margin-top: 2px;
    opacity: 0.7;
}

/* Category Faders - Compact layout: [dot+label button] [hide toggle] [slider] */
.category-faders { display: flex; flex-direction: column; gap: 4px; }
.category-fader { 
    display: grid; 
    grid-template-columns: 100px 18px 1fr; 
    align-items: center; 
    gap: 6px;
    height: 26px;
    transition: opacity 0.2s;
}

.category-fader.muted {
    opacity: 0.4;
}

.category-fader.muted .category-btn {
    opacity: 0.5;
}

.category-btn {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 3px 8px;
    background: #f8f8f8;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s;
}

.category-btn:hover {
    background: #f0f0f0;
    border-color: #ccc;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.category-btn:active {
    background: #e8e8e8;
    transform: translateY(1px);
}

.category-btn.focused {
    background: #e0e0e0;
    border-color: #bbb;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.08);
}

.category-btn .dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    flex-shrink: 0;
}

.category-btn .label {
    font-size: 0.62rem;
    color: #333;
    font-weight: 500;
}

.hide-toggle {
    width: 12px;
    height: 12px;
    background: #333;
    border: 2px solid #333;
    border-radius: 2px;
    cursor: pointer;
    transition: all 0.15s;
}

.hide-toggle:hover {
    background: #555;
    border-color: #555;
}

.hide-toggle:active {
    transform: scale(0.9);
}

.hide-toggle.hidden {
    background: transparent;
    border-color: #aaa;
}

/* Slider styling - no numbers */
.category-fader input[type="range"] {
    width: 100%;
    height: 4px;
    -webkit-appearance: none;
    appearance: none;
    background: #e0e0e0;
    border-radius: 2px;
    outline: none;
    cursor: pointer;
}

.category-fader input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 11px;
    height: 11px;
    background: #333;
    border-radius: 50%;
    cursor: pointer;
    transition: transform 0.1s;
}

.category-fader input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.15);
}

.category-fader input[type="range"]::-moz-range-thumb {
    width: 11px;
    height: 11px;
    background: #333;
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

/* Animation for cycling */
@keyframes pulse-glow {
    0%, 100% { 
        transform: scale(1); 
        box-shadow: 0 0 2px currentColor;
    }
    50% { 
        transform: scale(1.3); 
        box-shadow: 0 0 6px currentColor;
    }
}

/* Mode badge in summary */
.mode-badge {
    display: inline-block;
    font-size: 0.55rem;
    padding: 2px 6px;
    border-radius: 3px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.03em;
    margin-left: 8px;
    vertical-align: middle;
}

.mode-badge.composed {
    background: #dbeafe;
    color: #1e40af;
}

.mode-badge.consonance {
    background: #dcfce7;
    color: #166534;
}

/* Hide mobile-only elements on desktop */
.mobile-audio-overlay {
    display: none;
}

/* ═══════════════════════════════════════════════════════════════════════════════
   MOBILE RESPONSIVE LAYOUT - CLEAN REWRITE
   ═══════════════════════════════════════════════════════════════════════════════ */

@media (max-width: 900px) {
    /* Base reset - NO overflow restrictions */
    html, body {
        height: auto;
        overflow: visible; /* ✅ REQUIRED for sticky - NO overflow-x:hidden! */
    }
    
    /* Prevent horizontal scroll without breaking sticky */
    body {
        max-width: 100vw;
    }
    
    /* Main container - simple vertical stack */
    .app-container {
        display: block;
        height: auto;
        overflow: visible; /* ✅ REQUIRED for sticky */
        max-width: 100vw;
    }
    
    /* ═══ SIDEBAR - Becomes top section ═══ */
    .sidebar {
        position: relative;
        width: 100%;
        border-right: none;
        padding: 10px 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        overflow: visible; /* ✅ REQUIRED for sticky */
        overflow-x: clip; /* Safe alternative to hidden */
    }
    
    .title-section {
        padding-bottom: 6px;
        border-bottom: 1px solid #e5e5e5;
    }
    
    .app-title { font-size: 1.3rem; }
    .app-subtitle { font-size: 0.75rem; }
    
    .mode-section {
        padding: 4px 0;
        border-bottom: none;
    }
    
    .mode-btn {
        padding: 7px 10px;
        font-size: 0.7rem;
    }
    
    .mode-btn .mode-sub { font-size: 0.5rem; }
    
    /* Hide nav/controls in sidebar - show after viz */
    .sidebar .nav-section,
    .sidebar .controls-section {
        display: none;
    }
    
    /* ═══ MAIN CONTENT - NO overflow restrictions ═══ */
    .main-content {
        display: block;
        height: auto;
        overflow: visible; /* ✅ REQUIRED for sticky */
        position: relative;
    }
    
    /* ═══ VISUALIZATION - STICKY ═══ */
    .viz-container {
        position: -webkit-sticky; /* ✅ Safari prefix */
        position: sticky;
        top: 0;
        z-index: 100;
        width: 100%;
        height: 30vh;
        min-height: 150px;
        max-height: 220px;
        border-bottom: 1px solid #e5e5e5;
        background: #fff;
        overflow-x: clip; /* Safe - doesn't break sticky */
    }
    
    /* Spectrum canvas - leave room for audio panel */
    #spectrumCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: calc(100% - 68px) !important;
        height: 100% !important;
        z-index: 1;
    }
    
    /* Mobile audio overlay */
    .mobile-audio-overlay {
        display: flex !important;
        flex-direction: column;
        position: absolute;
        top: 0;
        right: 0;
        width: 68px;
        height: 100%;
        background: #fff;
        border-left: 1px solid #e5e5e5;
        font-family: 'JetBrains Mono', monospace;
        z-index: 5;
    }
    
    /* Mobile oscilloscope */
    .mobile-scope {
        height: 55px;
        min-height: 55px;
        background: #111;
        flex-shrink: 0;
    }
    
    .mobile-scope canvas,
    #mobileScopeCanvas {
        width: 100% !important;
        height: 100% !important;
        display: block;
    }
    
    .mobile-audio-overlay .audio-val {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        text-align: center;
        padding: 2px;
        border-bottom: 1px solid #eee;
    }
    
    .mobile-audio-overlay .audio-val:last-child {
        border-bottom: none;
    }
    
    .mobile-audio-overlay .val {
        font-size: 0.85rem;
        font-weight: 600;
        color: #111;
        line-height: 1.1;
    }
    
    .mobile-audio-overlay .lbl {
        font-size: 0.4rem;
        color: #888;
        text-transform: uppercase;
    }
    
    /* Play button */
    .play-btn {
        position: absolute;
        bottom: 50%;
        left: calc(50% - 60px);
        transform: translateY(50%);
        width: 54px;
        height: 54px;
        z-index: 20;
        pointer-events: auto !important;
        touch-action: manipulation;
        -webkit-tap-highlight-color: rgba(0,0,0,0.1);
    }
    
    .play-btn.playing {
        width: 40px;
        height: 40px;
        bottom: 8px;
        left: 8px;
        transform: none;
    }
    
    /* Hide axis labels on mobile */
    .axis-label { display: none; }
    .zoom-hint { display: none; }
    .reset-zoom-btn { display: none; }
    
    /* Hide desktop audio sidebar */
    .bottom-audio {
        display: none !important;
    }
    
    /* ═══ BOTTOM SECTION - All scrollable content ═══ */
    .bottom-section {
        display: block;
        height: auto;
        overflow: visible; /* ✅ REQUIRED for sticky */
    }
    
    .bottom-main {
        display: block;
        overflow: visible; /* ✅ REQUIRED for sticky */
    }
    
    /* Pathway info bar */
    .tier-pathway {
        grid-template-columns: auto 1fr;
        gap: 8px;
        padding: 10px 12px;
    }
    
    .pathway-metrics { display: none; }
    .pathway-name { font-size: 0.68rem; }
    .pathway-id { font-size: 0.6rem; padding: 3px 6px; }
    .pathway-cat-info .cat-label { font-size: 0.52rem; }
    .pathway-cat-info .subcat-label { font-size: 0.45rem; }
    
    /* Documentation */
    .tier-summary {
        padding: 10px;
        min-height: auto;
    }
    
    .docs-text { font-size: 0.72rem; }
    .docs-indent { font-size: 0.68rem; }
    
    /* Pathway summary text */
    .pathway-summary-text { font-size: 0.7rem; line-height: 1.4; }
    .pathway-summary-link { font-size: 0.65rem; }
    
    /* ═══ MOBILE NAV - Duplicated after docs ═══ */
    .mobile-nav {
        display: block !important;
        padding: 12px;
        background: #f9f9f9;
        border-top: 1px solid #e5e5e5;
    }
    
    .mobile-nav .nav-tagline {
        font-size: 0.72rem;
        margin-bottom: 10px;
    }
    
    .mobile-nav .nav-btn {
        display: flex;
        padding: 12px;
        margin-bottom: 8px;
    }
    
    .mobile-nav .nav-btn-title { font-size: 0.9rem; }
    .mobile-nav .nav-btn-title::after { width: 40px; }
    .mobile-nav .nav-btn-sub { font-size: 0.65rem; }
    
    .mobile-nav .key-findings-section {
        margin-top: 12px;
        padding: 10px;
        background: #fff;
    }
    
    .mobile-nav .key-finding-btn {
        padding: 10px;
    }
    
    .mobile-nav .key-finding-btn .finding-title {
        font-size: 0.8rem;
    }
    
    /* ═══ MOBILE CONTROLS ═══ */
    .mobile-controls {
        display: block !important;
        padding: 12px;
        background: #fff;
        border-top: 1px solid #e5e5e5;
    }
    
    .mobile-controls h3 {
        font-size: 0.7rem;
        margin-bottom: 10px;
    }
    
    .mobile-controls .control-group {
        margin-bottom: 14px;
    }
    
    .mobile-controls .control-group label {
        font-size: 0.7rem;
    }
    
    .mobile-controls .slider-value {
        font-size: 0.7rem;
    }
    
    .mobile-controls .category-fader {
        grid-template-columns: 90px 16px 1fr;
        height: 32px;
    }
    
    .mobile-controls .category-btn .label {
        font-size: 0.6rem;
    }
    
    /* Mobile subcategory section */
    .mobile-subcategory-section {
        background: #f8f8f8;
        padding: 10px;
        border-radius: 6px;
        margin-top: 8px;
    }
    
    .mobile-subcategory-section .subcategory-header {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 8px;
    }
    
    .mobile-subcategory-section .subcat-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
    }
    
    .mobile-subcategory-section .subcat-label {
        font-size: 0.65rem;
        font-weight: 500;
        color: #555;
        flex: 1;
    }
    
    .mobile-subcategory-section .subcat-nav-btn {
        width: 24px;
        height: 24px;
        border: 1px solid #ddd;
        background: #fff;
        border-radius: 4px;
        font-size: 1rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .mobile-subcategory-section .subcat-nav-btn:active {
        background: #eee;
    }
    
    .mobile-subcategory-section .mobile-solo-btn,
    .mobile-subcategory-section .mobile-stop-btn {
        width: 24px;
        height: 24px;
        border: 1px solid #ddd;
        background: #fff;
        border-radius: 4px;
        font-size: 0.65rem;
        font-weight: 600;
        cursor: pointer;
    }
    
    .mobile-subcategory-section .mobile-solo-btn.active {
        background: #fbbf24;
        border-color: #f59e0b;
        color: #000;
    }
    
    .mobile-subcategory-section .mobile-stop-btn.has-active {
        background: #ef4444;
        border-color: #dc2626;
        color: #fff;
    }
    
    .mobile-subcategory-faders {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 150px;
        overflow-y: auto;
    }
    
    .mobile-subcategory-faders .subcategory-fader {
        display: grid;
        grid-template-columns: 1fr 1fr;
        align-items: center;
        gap: 8px;
        height: 30px;
    }
    
    .mobile-subcategory-faders .subcat-btn {
        font-size: 0.6rem;
        padding: 6px 8px;
        text-align: left;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        cursor: pointer;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .mobile-subcategory-faders .subcat-btn.cycling {
        animation: mobile-pulse var(--pulse-duration, 350ms) ease-in-out infinite;
        background: var(--cat-color-light, #dcfce7);
        border-color: var(--cat-color, #22c55e);
        color: var(--cat-color, #22c55e);
        font-weight: 600;
    }
    
    @keyframes mobile-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    .mobile-subcategory-faders input[type="range"] {
        height: 4px;
    }
    
    /* References */
    .tier-refs {
        padding: 12px;
        font-size: 0.65rem;
        line-height: 1.6;
    }
    
    /* Finding display */
    .finding-quote { padding: 10px 12px; }
    .finding-quote p { font-size: 0.75rem; }
    .metabolite-chip, .pathway-chip { font-size: 0.7rem; padding: 4px 8px; }
    .finding-clinical { padding: 8px 10px; }
    .finding-clinical p { font-size: 0.75rem; }
    
    /* Modal */
    .modal { width: 95vw; max-height: 90vh; }
    .modal-header h2 { font-size: 1rem; }
    .methods-text { font-size: 0.72rem; }
}

/* Extra small screens */
@media (max-width: 480px) {
    .app-title { font-size: 1.15rem; }
    .app-subtitle { font-size: 0.7rem; }
    .mode-btn { padding: 6px 8px; font-size: 0.65rem; }
    .viz-container { height: 28vh; min-height: 140px; }
    .mobile-audio-overlay .val { font-size: 0.75rem; }
    .play-btn { width: 48px; height: 48px; }
}
    </style>
</head>
<body>
    <div class="app-container">
        <aside class="sidebar">
            <div class="title-section">
<h1 class="app-title"><span class="solid">Metab</span><span class="hollow">o</span><span class="solid">lic</span> <span class="hollow">Harm</span><span class="solid">o</span><span class="hollow">ny</span></h1>
<p class="app-subtitle"><span class="hollow">The Human Gut Microbiome Sonified</span></p>
            </div>
            
            <!-- MODE TOGGLE - Composed vs Consonance -->
            <div class="mode-section">
                <div class="mode-toggle" id="modeToggle">
                    <button class="mode-btn active" data-mode="composed">
                        Composed
                        <span class="mode-sub">Prime architecture</span>
                    </button>
                    <button class="mode-btn" data-mode="consonance">
                        Consonance
                        <span class="mode-sub">Abundance ranking</span>
                    </button>
                </div>
            </div>
            <nav class="nav-section">
                <div class="nav-tagline">Listen to your Gut</div>
                <div class="nav-buttons">
                    <button class="nav-btn active" data-view="healthy">
                        <span class="indicator"></span>
                        <div class="nav-btn-text">
                            <span class="nav-btn-title">Healthy Reference</span>
                            <span class="nav-btn-sub" id="healthyNavSub">389 Curated Pathways • curatedMetagenomicData</span>
                        </div>
                    </button>
                    
                    <!-- MS Comparison Button - triggers inference animation -->
                    <button class="nav-btn ms-compare-btn" data-view="ms" id="msCompareBtn">
                        <span class="indicator"></span>
                        <div class="nav-btn-text">
                            <span class="nav-btn-title">Multiple Sclerosis</span>
                            <span class="nav-btn-sub">Cantoni et al. 2022; Smusz et al. 2025</span>
                        </div>
                    </button>
                </div>
                
                <!-- Key Findings Section - disabled until MS mode active -->
                <div class="key-findings-section" id="keyFindingsSection">
                    <h4>Key Research Findings • <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC12471209/" target="_blank">PMC12471209</a> (2025)<span></h4>   
                  <!--  </span> class="findings-status" id="findingsStatus">(enable MS comparison)</span></h4> -->
                    
                    <div class="key-findings-grid" id="keyFindingsGrid">
                        <!-- Kynurenine - Neurotoxic shift -->
                        <button class="key-finding-btn kynurenine-btn disabled" data-finding="kynurenine" disabled>
                            <span class="finding-dot" style="background: #8b5cf6;"></span>
                            <div class="finding-text">
                                <span class="finding-title">Kynurenine Pathway</span>
                                <span class="finding-direction depleted">neurotoxic shift</span>
                            </div>
                        </button>

                        <!-- Energy Metabolism - Mitochondrial -->
                        <button class="key-finding-btn energy-btn disabled" data-finding="energy" disabled>
                            <span class="finding-dot" style="background: #22c55e;"></span>
                            <div class="finding-text">
                                <span class="finding-title">Energy Metabolism</span>
                                <span class="finding-direction depleted">mitochondrial stress</span>
                            </div>
                        </button>
                  


                        <!-- SCFA Depletion - Strongest evidence -->
                        <button class="key-finding-btn scfa-btn disabled" data-finding="fermentation" disabled>
                            <span class="finding-dot" style="background: #06b6d4;"></span>
                            <div class="finding-text">
            <span class="finding-title">SCFA Depletion</span>
            <span class="finding-direction">immune disruption</span>
                            </div>
                        </button>
                        
                    <!--<p class="findings-citation">
                        Based on <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC12471209/" target="_blank">PMC12471209</a> (2025)
                    </p> -->
                </div>
            </nav>
            <div class="controls-section">
             <!--   <h3>Controls</h3> -->
                <div class="control-group">
                    <label>Master Volume</label>
                    <div class="slider-row">
                        <input type="range" id="volumeSlider" min="0" max="100" value="40">
                        <span class="slider-value" id="volumeValue">40%</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Category Mix</label>
                    <div class="category-faders" id="categoryFaders">
                        <div class="category-fader" data-category="energy">
                            <button class="category-btn" data-category="energy">
                                <span class="dot" style="background:#22c55e;"></span>
                                <span class="label">Energy</span>
                            </button>
                            <button class="hide-toggle" data-category="energy" title="Hide"></button>
                            <input type="range" data-category="energy" min="0" max="100" value="100">
                        </div>
                        <div class="category-fader" data-category="biosynthesis">
                            <button class="category-btn" data-category="biosynthesis">
                                <span class="dot" style="background:#3b82f6;"></span>
                                <span class="label">Biosynthesis</span>
                            </button>
                            <button class="hide-toggle" data-category="biosynthesis" title="Hide"></button>
                            <input type="range" data-category="biosynthesis" min="0" max="100" value="100">
                        </div>
                        <div class="category-fader" data-category="degradation">
                            <button class="category-btn" data-category="degradation">
                                <span class="dot" style="background:#ef4444;"></span>
                                <span class="label">Degradation</span>
                            </button>
                            <button class="hide-toggle" data-category="degradation" title="Hide"></button>
                            <input type="range" data-category="degradation" min="0" max="100" value="100">
                        </div>
                        <div class="category-fader" data-category="salvage">
                            <button class="category-btn" data-category="salvage">
                                <span class="dot" style="background:#eab308;"></span>
                                <span class="label">Salvage</span>
                            </button>
                            <button class="hide-toggle" data-category="salvage" title="Hide"></button>
                            <input type="range" data-category="salvage" min="0" max="100" value="100">
                        </div>
                        <div class="category-fader" data-category="other">
                            <button class="category-btn" data-category="other">
                                <span class="dot" style="background:#6b7280;"></span>
                                <span class="label">Other</span>
                            </button>
                            <button class="hide-toggle" data-category="other" title="Hide"></button>
                            <input type="range" data-category="other" min="0" max="100" value="100">
                        </div>
                    </div>
                </div>
                <div class="control-group subcategory-section" id="subcategorySection">
                    <div class="subcategory-header">
                        <span class="cat-indicator" id="subcatIndicator" style="background:#22c55e;"></span>
                        <span id="subcatLabel">Energy Subcategories</span>
                        <button class="subcat-nav-btn" id="subcatNext" title="Next category">›</button>
                        <button class="solo-all-btn" id="soloAllBtn" title="Solo active sequences">S</button>
                        <button class="stop-all-btn" id="stopAllBtn" title="Stop all sequences">■</button>
                    </div>
                    <div class="subcategory-faders" id="subcategoryFaders">
                        <!-- Dynamically populated -->
                    </div>
                </div>
                <div class="control-group">
                    <label>Fundamental Frequency</label>
                    <div class="slider-row">
                        <input type="range" id="fundamentalSlider" min="200" max="1200" value="660">
                        <span class="slider-value" id="fundamentalValue">660 Hz</span>
                    </div>
                </div>
            </div>
        </aside>
        <main class="main-content">
            <div class="viz-container" id="vizContainer">
                <canvas id="spectrumCanvas"></canvas>
                <span class="axis-label x-axis">Frequency (Hz) →</span>
                <span class="axis-label y-axis">← Abundance</span>
                <span class="zoom-hint">Scroll to zoom · Drag to pan · Double-click to reset</span>
                <button class="reset-zoom-btn" id="resetZoomBtn">Reset Zoom</button>
                <button class="play-btn" id="playBtn"><svg viewBox="0 0 24 24" id="playIcon"><path d="M8 5v14l11-7z"/></svg></button>
                
                <!-- Mobile-only audio info overlay -->
                <div class="mobile-audio-overlay" id="mobileAudioOverlay">
                    <div class="mobile-scope">
                        <canvas id="mobileScopeCanvas"></canvas>
                    </div>
                    <div class="audio-val">
                        <div class="val" id="mobileRatio">1/1</div>
                        <div class="lbl">ratio</div>
                    </div>
                    <div class="audio-val">
                        <div class="val" id="mobileHz">660</div>
                        <div class="lbl">hz</div>
                    </div>
                    <div class="audio-val">
                        <div class="val" id="mobileCents">0</div>
                        <div class="lbl">cents</div>
                    </div>
                </div>
            </div>
            <div class="bottom-section">
                <!-- Main content area (3 tiers stacked) -->
                <div class="bottom-main">
                    
                    <!-- Tier 1: Selected Pathway (stable grid layout) -->
                    <div class="tier-pathway">
                        <div class="pathway-identity-box energy" id="pwdIdentityBox">
                            <span class="pathway-id energy" id="pwdId">PWY-1042</span>
                            <div class="pathway-cat-info">
                                <span class="cat-label" id="pwdCategory">ENERGY</span>
                                <span class="subcat-label" id="pwdSubcat">Glycolysis</span>
                            </div>
                        </div>
                        <span class="pathway-name" id="pwdName">glycolysis IV (plant cytosol)</span>
                        <div class="pathway-metrics">
                            <div class="pathway-metric">
                                <span class="value" id="pwdAbundance">—</span>
                                <span class="label">abd</span>
                            </div>
                            <div class="pathway-metric">
                                <span class="value" id="pwdPrev">99.9%</span>
                                <span class="label">prev</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Tier 2: Main Content Area -->
                    <div class="tier-summary" id="tierSummary">
                        
                        <!-- Pathway Summary (always visible, updates on hover) -->
                        <div class="pathway-summary-section" id="pathwaySummarySection">
                            <div class="pathway-summary-text" id="pathwaySummaryText">
                                Hover over a pathway to see its description from MetaCyc.
                            </div>
                            <a class="pathway-summary-link" id="pathwaySummaryLink" href="#" target="_blank" style="display:none;">View on MetaCyc →</a>
                        </div>
                        
                        <!-- Documentation (swaps between healthy/MS modes) -->
                        <div class="docs-section" id="docsSection">
                            <!-- Healthy mode docs -->
                            <div id="healthyDocs">
                                <div class="docs-label">Documentation & Methods</div>
                                <div class="docs-text">
                                    <p>This harmonic model of the human gut microbiome is based on <a href="#" onclick="openMethods(); return false;" class="docs-link">4,869 healthy samples</a> collected from <a href="https://waldronlab.io/curatedMetagenomicData/" target="_blank" class="docs-link">curatedMetagenomicData</a>. <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC3245006/" target="_blank" class="docs-link">Metabolic pathways</a> represent chains of enzymatic and biochemical reactions. A unique harmonic ratio was mapped to each pathway:</p>
                                    <span class="docs-indent"><strong>by Consonance</strong> — Pathways ranked by prevalence tier, then by abundance. The most consonant ratios (lowest n×d) assigned to the highest-ranked pathways from raw HUMAnN3 output.</span>
                                    <span class="docs-indent"><strong>by Composition</strong> — <a href="#" onclick="openCurated(); return false;" class="docs-link">350 curated pathways</a> mapped using prime-limit structures. Energy uses 2-limit (octaves), biosynthesis 5–7 limit, degradation subharmonics. <a href="https://github.com/ThomasListens/ThomasListens.github.io/blob/main/MetabolicHarmony/MetabolicHarmony_v6.ipynb" target="_blank" class="docs-link">View Score →</a></span>
                                </div>
                            </div>
                            
                            <!-- MS mode docs -->
                            <div id="msDocs" style="display: none;">
                                <div class="docs-label">Multiple Sclerosis Characterization</div>
                                <div class="docs-text">
                                    <p>This sonification reveals differences between our healthy reference and the MS gut microbiome.  <a href="https://pubmed.ncbi.nlm.nih.gov/35059609/" target="_blank" class="docs-link">Cantoni et al. (2022)</a> identified 66 differentially abundant pathways between MS patients and controls. <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC12471209/" target="_blank" class="docs-link">Smusz et al. (2025)</a> synthesized metabolite data from 29 studies, which we used to infer additional pathway-level changes.</p>
                                    <p>The gut-brain axis enables bidirectional communication between intestinal bacteria and the central nervous system through metabolites, immune signaling, and the vagus nerve. Disrupted microbial metabolism—particularly depleted short-chain fatty acids and altered tryptophan catabolism—may contribute to neuroinflammation and disease progression.</p>
                                    <p class="docs-cta">Select a key finding to hear specific dysregulated pathways.</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Key finding content (hidden by default, replaces everything) -->
                        <div id="findingContent" style="display: none;">
                            <div class="finding-header">
                                <div class="finding-title-block">
                                    <span class="finding-title" id="findingTitle">SCFA Depletion</span>
                                    <span class="finding-expansion" id="findingExpansion"></span>
                                </div>
                                <span class="finding-subtitle" id="findingSubtitle">immune disruption</span>
                                <button class="close-btn" id="closeFindingBtn" title="Close">✕</button>
                            </div>
                            
                            <blockquote class="finding-quote">
                                <p id="findingQuoteText">"Quote from the paper..."</p>
                                <cite id="findingCitation">— Source</cite>
                            </blockquote>
                            
                            <div class="finding-evidence">
                                <div class="evidence-label">Metabolite Evidence</div>
                                <div class="metabolite-chips" id="findingMetaboliteChips"></div>
                            </div>
                            
                            <div class="finding-pathways">
                                <div class="evidence-label">Affected Pathways</div>
                                <div class="pathway-chips" id="findingPathwayChips"></div>
                            </div>
                            
                            <div class="finding-clinical" id="findingClinical">
                                <p id="findingClinicalText"></p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ═══ MOBILE-ONLY: Navigation (hidden on desktop) ═══ -->
                    <div class="mobile-nav" style="display:none;">
                        <div class="nav-tagline">Listen to your Gut</div>
                        <div class="nav-buttons">
                            <button class="nav-btn mobile-nav-btn active" data-view="healthy">
                                <span class="indicator"></span>
                                <div class="nav-btn-text">
                                    <span class="nav-btn-title">Healthy Reference</span>
                                    <span class="nav-btn-sub">Curated Pathways</span>
                                </div>
                            </button>
                            <button class="nav-btn mobile-nav-btn ms-compare-btn" data-view="ms">
                                <span class="indicator"></span>
                                <div class="nav-btn-text">
                                    <span class="nav-btn-title">Multiple Sclerosis</span>
                                    <span class="nav-btn-sub">Cantoni 2022; Smusz 2025</span>
                                </div>
                            </button>
                        </div>
                        <div class="key-findings-section mobile-findings" id="mobileKeyFindings">
                            <h4>Key Research Findings</h4>
                            <div class="key-findings-grid">
                                <button class="key-finding-btn mobile-finding-btn kynurenine-btn disabled" data-finding="kynurenine" disabled>
                                    <span class="finding-dot" style="background: #8b5cf6;"></span>
                                    <div class="finding-text">
                                        <span class="finding-title">Kynurenine Pathway</span>
                                        <span class="finding-direction depleted">neurotoxic shift</span>
                                    </div>
                                </button>
                                <button class="key-finding-btn mobile-finding-btn energy-btn disabled" data-finding="energy" disabled>
                                    <span class="finding-dot" style="background: #22c55e;"></span>
                                    <div class="finding-text">
                                        <span class="finding-title">Energy Metabolism</span>
                                        <span class="finding-direction depleted">mitochondrial stress</span>
                                    </div>
                                </button>
                                <button class="key-finding-btn mobile-finding-btn scfa-btn disabled" data-finding="fermentation" disabled>
                                    <span class="finding-dot" style="background: #06b6d4;"></span>
                                    <div class="finding-text">
                                        <span class="finding-title">SCFA Depletion</span>
                                        <span class="finding-direction">immune disruption</span>
                                    </div>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ═══ MOBILE-ONLY: Controls (hidden on desktop) ═══ -->
                    <div class="mobile-controls" style="display:none;">
                        <h3>Controls</h3>
                        <div class="control-group">
                            <label>Master Volume</label>
                            <div class="slider-row">
                                <input type="range" class="mobile-volume-slider" min="0" max="100" value="40">
                                <span class="slider-value mobile-volume-value">40%</span>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Category Mix</label>
                            <div class="category-faders mobile-category-faders">
                                <div class="category-fader" data-category="energy">
                                    <button class="category-btn mobile-category-btn" data-category="energy">
                                        <span class="dot" style="background:#22c55e;"></span>
                                        <span class="label">Energy</span>
                                    </button>
                                    <button class="hide-toggle mobile-hide-toggle" data-category="energy"></button>
                                    <input type="range" class="mobile-cat-slider" data-category="energy" min="0" max="100" value="100">
                                </div>
                                <div class="category-fader" data-category="biosynthesis">
                                    <button class="category-btn mobile-category-btn" data-category="biosynthesis">
                                        <span class="dot" style="background:#3b82f6;"></span>
                                        <span class="label">Biosynthesis</span>
                                    </button>
                                    <button class="hide-toggle mobile-hide-toggle" data-category="biosynthesis"></button>
                                    <input type="range" class="mobile-cat-slider" data-category="biosynthesis" min="0" max="100" value="100">
                                </div>
                                <div class="category-fader" data-category="degradation">
                                    <button class="category-btn mobile-category-btn" data-category="degradation">
                                        <span class="dot" style="background:#f59e0b;"></span>
                                        <span class="label">Degradation</span>
                                    </button>
                                    <button class="hide-toggle mobile-hide-toggle" data-category="degradation"></button>
                                    <input type="range" class="mobile-cat-slider" data-category="degradation" min="0" max="100" value="100">
                                </div>
                                <div class="category-fader" data-category="salvage">
                                    <button class="category-btn mobile-category-btn" data-category="salvage">
                                        <span class="dot" style="background:#ec4899;"></span>
                                        <span class="label">Salvage</span>
                                    </button>
                                    <button class="hide-toggle mobile-hide-toggle" data-category="salvage"></button>
                                    <input type="range" class="mobile-cat-slider" data-category="salvage" min="0" max="100" value="100">
                                </div>
                                <div class="category-fader" data-category="other">
                                    <button class="category-btn mobile-category-btn" data-category="other">
                                        <span class="dot" style="background:#6b7280;"></span>
                                        <span class="label">Other</span>
                                    </button>
                                    <button class="hide-toggle mobile-hide-toggle" data-category="other"></button>
                                    <input type="range" class="mobile-cat-slider" data-category="other" min="0" max="100" value="100">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Subcategory Section -->
                        <div class="control-group mobile-subcategory-section">
                            <div class="subcategory-header">
                                <span class="subcat-indicator mobile-subcat-indicator" id="mobileSubcatIndicator" style="background:#22c55e;"></span>
                                <label class="subcat-label" id="mobileSubcatLabel">Energy</label>
                                <button class="subcat-nav-btn mobile-subcat-next" id="mobileSubcatNext">›</button>
                                <button class="solo-all-btn mobile-solo-btn" id="mobileSoloBtn" title="Solo sequences">S</button>
                                <button class="stop-all-btn mobile-stop-btn" id="mobileStopBtn" title="Stop all">■</button>
                            </div>
                            <div class="subcategory-faders mobile-subcategory-faders" id="mobileSubcategoryFaders">
                                <!-- Populated dynamically -->
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>Fundamental Frequency</label>
                            <div class="slider-row">
                                <input type="range" class="mobile-fundamental-slider" min="200" max="1200" value="660">
                                <span class="slider-value mobile-fundamental-value">660 Hz</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- References footer -->
                    <div class="tier-refs" id="tierRefs">
                        <a href="https://metacyc.org/" target="_blank">MetaCyc</a> · 
                        <a href="https://waldronlab.io/curatedMetagenomicData/" target="_blank">curatedMetagenomicData</a> · 
                        <a href="https://enteropathway.org/" target="_blank">Enteropathway</a> · 
                        <a href="https://pubmed.ncbi.nlm.nih.gov/35059609/" target="_blank">Cantoni 2022</a> · 
                        <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC12471209/" target="_blank">Smusz 2025</a> · 
                        <a href="https://www.amazon.com/Genesis-Music-Account-Creative-Fulfillment/dp/0306801063" target="_blank">Partch, <em>Genesis of a Music</em></a> · 
                        <a href="https://www.kylegann.com/Octave.html" target="_blank">Gann, <em>Anatomy of an Octave</em></a>
                    </div>
                </div>
                
                <!-- Audio sidebar (right side) -->
                <div class="bottom-audio">
                    <div class="scope-section">
                        <div class="oscilloscope"><canvas id="scopeCanvas"></canvas></div>
                    </div>
                    <div class="audio-section">
                        <div class="audio-item ratio-main">
                            <div class="value" id="ratioValue">1/1</div>
                            <div class="label">Ratio</div>
                        </div>
                        <div class="audio-item consonance">
                            <div class="value" id="intervalValue">1</div>
                            <div class="label">Consonance (n×d)</div>
                        </div>
                        <div class="audio-item">
                            <div class="value" id="freqValue">660</div>
                            <div class="label">Hertz</div>
                        </div>
                        <div class="audio-item">
                            <div class="value" id="centsValue">0</div>
                            <div class="label">Cents</div>
                        </div>
                    </div>
                    <div class="signature">Love Grows Within · 2025</div>
                </div>
            </div>
        </main>
    </div>
    <div id="methodsModal" class="modal-overlay">
  <div class="modal">
    <div class="modal-header">
      <h2>Healthy Gut Reference Cohort</h2>
      <button class="modal-close" aria-label="Close">×</button>
    </div>

    <div class="modal-content">
      <pre class="methods-text">
curatedMetagenomicData – Healthy Reference

Generated: 2025-12-25 15:47:20.862435
R version: R version 4.5.2 (2025-10-31 ucrt)

FILTERING CRITERIA APPLIED:
  - Disease status: 'healthy' or 'control'
  - Body site: stool
  - Age: 18-65 years
  - Antibiotics: excluded current users
  - Pregnancy/lactation: excluded
  - BMI: 18.5-30 (normal to overweight, excluding obese)
  - Excluded disease-focused studies

COHORT SUMMARY:
  Total samples: 4869
  Total studies: 40
  Total pathways: 67175

DEMOGRAPHICS:
  Age: mean = 40.0, SD = 13.3, range = 18 - 65
  Gender: female = 2888, male = 1915

STUDIES INCLUDED:
  AsnicarF_2021: n=916, mean_age=44.2, %female=71.6
  LifeLinesDeep_2016: n=911, mean_age=42.7, %female=57.2
  ZeeviD_2015: n=654, mean_age=40.5, %female=58.9
  SchirmerM_2016: n=432, mean_age=26.5, %female=57.4
  BritoIL_2016: n=143, mean_age=44.1, %female=59.4
  CosteaPI_2017: n=137, mean_age=45.1, %female=60.6
  HansenLBS_2018: n=137, mean_age=47.8, %female=59.9
  HMP_2012: n=135, mean_age=26.0, %female=45.2
  ShaoY_2019: n=114, mean_age=34.1, %female=44.7
  PehrssonE_2016: n=104, mean_age=37.8, %female=56.7
  PasolliE_2019: n=102, mean_age=34.4, %female=47.1
  XieH_2016: n=100, mean_age=56.9, %female=100.0
  DeFilippisF_2019: n=90, mean_age=39.4, %female=51.1
  MetaCardis_2020_a: n=85, mean_age=49.8, %female=60.0
  DhakanDB_2019: n=76, mean_age=34.8, %female=52.6
  Bengtsson-PalmeJ_2015: n=70, mean_age=25.5, %female=74.3
  ZhuF_2020: n=70, mean_age=33.5, %female=47.1
  LeChatelierE_2013: n=65, mean_age=54.6, %female=61.5
  KeohaneDM_2020: n=57, mean_age=32.7, %female=52.6
  RubelMA_2020: n=55, mean_age=42.4, %female=61.8
  YeZ_2018: n=39, mean_age=37.7, %female=28.2
  TettAJ_2019_a: n=38, mean_age=29.0, %female=0.0
  LokmerA_2019: n=37, mean_age=46.8, %female=37.8
  RaymondF_2016: n=36, mean_age=25.2, %female=58.3
  Obregon-TitoAJ_2015: n=32, mean_age=31.5, %female=59.4
  RampelliS_2015: n=32, mean_age=33.3, %female=43.8
  KaurK_2020: n=28, mean_age=34.7, %female=10.7
  GuptaA_2019: n=25, mean_age=39.1, %female=64.0
  TettAJ_2019_c: n=23, mean_age=29.3, %female=100.0
  TettAJ_2019_b: n=22, mean_age=33.1, %female=0.0
  ThomasAM_2019_c: n=19, mean_age=52.6, %female=42.1
  SmitsSA_2017: n=18, mean_age=43.2, %female=44.4
  HanniganGD_2017: n=17, mean_age=53.6, %female=52.9
  FerrettiP_2018: n=15, mean_age=34.2, %female=100.0
  WampachL_2018: n=14, mean_age=34.1, %female=100.0
  BedarfJR_2017: n=10, mean_age=58.2, %female=0.0
  Heitz-BuschartA_2016: n=6, mean_age=59.0, %female=100.0
  SankaranarayananK_2015: n=2, mean_age=37.5, %female=50.0
  VincentC_2016: n=2, mean_age=63.0, %female=50.0
  LiJ_2014: n=1, mean_age=50.0, %female=0.0

TOP 50 PATHWAYS BY ABUNDANCE:
(These represent the most consistently abundant pathways in healthy guts)

    1. PWY-1042
       median=0.000589, prevalence=99.9%, IQR=[0.000527, 0.000653]
    2. PWY-6737
       median=0.000561, prevalence=99.9%, IQR=[0.000468, 0.000641]
    3. PWY-7219
       median=0.000559, prevalence=99.9%, IQR=[0.000503, 0.000626]
    4. PWY-5686
       median=0.000550, prevalence=99.9%, IQR=[0.000491, 0.000612]
    5. PWY-7111
       median=0.000548, prevalence=99.9%, IQR=[0.000481, 0.000617]
    6. ILEUSYN-PWY
       median=0.000548, prevalence=99.9%, IQR=[0.000481, 0.000617]
    7. VALSYN-PWY
       median=0.000548, prevalence=99.9%, IQR=[0.000481, 0.000617]
    8. PWY-6386
       median=0.000544, prevalence=99.9%, IQR=[0.000480, 0.000606]
    9. DTDPRHAMSYN-PWY
       median=0.000542, prevalence=99.9%, IQR=[0.000459, 0.000646]
   10. PWY-7221
       median=0.000539, prevalence=99.9%, IQR=[0.000487, 0.000598]
   11. PWY-6387
       median=0.000537, prevalence=99.9%, IQR=[0.000475, 0.000599]
   12. PEPTIDOGLYCANSYN-PWY
       median=0.000529, prevalence=99.9%, IQR=[0.000468, 0.000593]
   13. PWY-6609
       median=0.000523, prevalence=99.9%, IQR=[0.000453, 0.000590]
   14. TRNA-CHARGING-PWY
       median=0.000521, prevalence=99.9%, IQR=[0.000467, 0.000587]
   15. PWY-6385
       median=0.000515, prevalence=99.9%, IQR=[0.000451, 0.000582]
   16. COA-PWY-1
       median=0.000492, prevalence=99.9%, IQR=[0.000435, 0.000541]
   17. PWY-6163
       median=0.000491, prevalence=99.8%, IQR=[0.000432, 0.000547]
   18. PWY-6122
       median=0.000472, prevalence=99.9%, IQR=[0.000417, 0.000529]
   19. PWY-6277
       median=0.000472, prevalence=99.9%, IQR=[0.000417, 0.000529]
   20. ARO-PWY
       median=0.000468, prevalence=99.8%, IQR=[0.000403, 0.000524]
   21. PWY-6151
       median=0.000455, prevalence=99.9%, IQR=[0.000389, 0.000527]
   22. PWY-6700
       median=0.000453, prevalence=99.9%, IQR=[0.000382, 0.000525]
   23. PWY-3841
       median=0.000452, prevalence=99.9%, IQR=[0.000402, 0.000505]
   24. BRANCHED-CHAIN-AA-SYN-PWY
       median=0.000446, prevalence=99.9%, IQR=[0.000384, 0.000518]
   25. PWY-5097
       median=0.000443, prevalence=99.9%, IQR=[0.000398, 0.000491]
   26. COMPLETE-ARO-PWY
       median=0.000442, prevalence=99.8%, IQR=[0.000383, 0.000497]
   27. PWY-6121
       median=0.000442, prevalence=99.9%, IQR=[0.000392, 0.000492]
   28. PWY-7400
       median=0.000430, prevalence=99.9%, IQR=[0.000348, 0.000496]
   29. ARGSYNBSUB-PWY
       median=0.000430, prevalence=99.9%, IQR=[0.000339, 0.000503]
   30. ARGSYN-PWY
       median=0.000430, prevalence=99.9%, IQR=[0.000347, 0.000497]
   31. PWY-5103
       median=0.000422, prevalence=99.9%, IQR=[0.000358, 0.000501]
   32. CALVIN-PWY
       median=0.000418, prevalence=99.9%, IQR=[0.000360, 0.000468]
   33. PWY-4242
       median=0.000415, prevalence=99.9%, IQR=[0.000360, 0.000468]
   34. COA-PWY
       median=0.000414, prevalence=99.9%, IQR=[0.000362, 0.000466]
   35. 1CMET2-PWY
       median=0.000408, prevalence=99.9%, IQR=[0.000363, 0.000450]
   36. PWY-2942
       median=0.000407, prevalence=99.9%, IQR=[0.000365, 0.000451]
   37. PWY-5667
       median=0.000404, prevalence=99.8%, IQR=[0.000346, 0.000455]
   38. PWY0-1319
       median=0.000404, prevalence=99.8%, IQR=[0.000346, 0.000455]
   39. PWY-5695
       median=0.000401, prevalence=99.8%, IQR=[0.000331, 0.000465]
   40. PWY-7229
       median=0.000369, prevalence=99.8%, IQR=[0.000328, 0.000411]
   41. HISTSYN-PWY
       median=0.000368, prevalence=99.9%, IQR=[0.000323, 0.000421]
   42. GLUTORN-PWY
       median=0.000365, prevalence=99.9%, IQR=[0.000285, 0.000434]
   43. PWY-724
       median=0.000364, prevalence=99.8%, IQR=[0.000321, 0.000400]
   44. ANAGLYCOLYSIS-PWY
       median=0.000363, prevalence=99.8%, IQR=[0.000306, 0.000414]
   45. RIBOSYN2-PWY
       median=0.000346, prevalence=99.8%, IQR=[0.000287, 0.000415]
   46. PWY0-1296
       median=0.000345, prevalence=99.8%, IQR=[0.000276, 0.000413]
   47. PANTOSYN-PWY
       median=0.000345, prevalence=99.8%, IQR=[0.000295, 0.000391]
   48. PWY-3001
       median=0.000339, prevalence=99.9%, IQR=[0.000300, 0.000380]
   49. PWY-7199
       median=0.000335, prevalence=99.8%, IQR=[0.000263, 0.000398]
   50. PWY-6123
       median=0.000334, prevalence=99.9%, IQR=[0.000287, 0.000380]

      </pre>
    </div>
  </div>
</div>

    <div id="curatedModal" class="modal-overlay">
  <div class="modal">
    <div class="modal-header">
      <h2>Pathway Curation Methodology</h2>
      <button class="modal-close" aria-label="Close">×</button>
    </div>

    <div class="modal-content">
      <pre class="methods-text">
350 pathways curated from 597 raw HUMAnN3 (41% reduction)

REMOVE:
─────────────────────────────────────
• Suspected HUMAnN3 gap-fill artifact
• Taxonomic outlier (plant, fungi, mammalian)
• Closely related entry point or superpathway
• Industrial/xenobiotic substrate

KEEP:
─────────────────────────────────────
• Functionally distinct (different end products)
• Cross-verified in Enteropathway database
• Documented in gut microbiome literature

EXAMPLE:
─────────────────────────────────────
PWY-6606 "guanosine nucleotides degradation II"
  → 98.4% prevalence but REMOVED
  → MetaCyc: Embryophyta/Fungi only

PWY-6608 "guanosine nucleotides degradation III"  
  → 99.3% prevalence and KEPT
  → MetaCyc: Bacteria (no guanosine deaminase)

High prevalence ≠ gut relevance.
Always verify taxonomic range.
      </pre>
    </div>
  </div>
</div>
    <script src="js/pathways_v7.js"></script>
    <script src="js/ms-key-findings-v6.js"></script>
    <script src="js/pathway_summaries.js"></script>
    <script>
    // Methods Modal
    const methodsModal = document.getElementById('methodsModal');
    const methodsCloseBtn = methodsModal.querySelector('.modal-close');

    function openMethods() {
      methodsModal.classList.add('active');
    }

    function closeMethods() {
      methodsModal.classList.remove('active');
    }

    methodsCloseBtn.addEventListener('click', closeMethods);
    methodsModal.addEventListener('click', (e) => {
      if (e.target === methodsModal) closeMethods();
    });

    // Curated Modal
    const curatedModal = document.getElementById('curatedModal');
    const curatedCloseBtn = curatedModal.querySelector('.modal-close');

    function openCurated() {
      curatedModal.classList.add('active');
    }

    function closeCurated() {
      curatedModal.classList.remove('active');
    }

    curatedCloseBtn.addEventListener('click', closeCurated);
    curatedModal.addEventListener('click', (e) => {
      if (e.target === curatedModal) closeCurated();
    });

    // ESC key closes any modal
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeMethods();
        closeCurated();
      }
    });
        // ===========================================
        // CONFIGURATION
        // ===========================================
        const CONFIG = {
            fundamental: 660, volume: 0.4, currentView: 'healthy', currentMode: 'composed',
            categoryGains: { energy: 1.0, biosynthesis: 1.0, degradation: 1.0, salvage: 1.0, other: 1.0, superpathways: 1.0 },
            hiddenCategories: { energy: false, biosynthesis: false, degradation: false, salvage: false, other: false, superpathways: false },
            subcategoryGains: {},
            colors: { 
                energy: '#22c55e', 
                biosynthesis: '#3b82f6', 
                degradation: '#ef4444', 
                salvage: '#eab308', 
                other: '#6b7280',
                superpathways: '#8b5cf6'
            },
            // Category color gradients (base → highlight) - for Composed mode
            colorGradients: {
                energy: ['#166534', '#22c55e', '#4ade80', '#86efac'],        // dark green → light green
                biosynthesis: ['#1e3a5f', '#3b82f6', '#60a5fa', '#93c5fd'],  // dark blue → light blue
                degradation: ['#991b1b', '#ef4444', '#f87171', '#fca5a5'],   // dark red → light red
                salvage: ['#854d0e', '#eab308', '#facc15', '#fde047'],       // dark amber → light amber
                other: ['#374151', '#6b7280', '#9ca3af', '#d1d5db'],         // dark gray → light gray
                superpathways: ['#581c87', '#8b5cf6', '#a78bfa', '#c4b5fd']  // dark purple → light purple
            },
            // Prime-based colors (HSL) - for Consonance mode
            // Based on HUMAnN3 harmonic relationships
            primeColors: {
                2:  { h: 210, s: 55, l: 48 },   // Blue - octaves
                3:  { h: 160, s: 50, l: 42 },   // Teal/green - fifths
                5:  { h: 45,  s: 60, l: 48 },   // Gold/amber - thirds
                7:  { h: 20,  s: 55, l: 48 },   // Orange - septimal
                11: { h: 335, s: 50, l: 50 },   // Pink/magenta - eleventh
                13: { h: 270, s: 45, l: 52 },   // Purple - thirteenth
                x:  { h: 220, s: 25, l: 50 }    // Muted blue - higher primes
            }
        };
        
        // Helper: Get prime factors of a number
        function getPrimeFactors(n) {
            const factors = {};
            [2, 3, 5, 7, 11, 13].forEach(p => {
                while (n % p === 0) { 
                    factors[p] = (factors[p] || 0) + 1; 
                    n /= p; 
                }
            });
            if (n > 1) factors.x = 1;  // Higher primes
            return factors;
        }
        
        // Helper: Get prime factors of a ratio (n/d)
        function getRatioFactors(n, d) {
            const nf = getPrimeFactors(n);
            const df = getPrimeFactors(d);
            const allFactors = { ...nf };
            for (const [p, c] of Object.entries(df)) {
                allFactors[p] = (allFactors[p] || 0) + c;
            }
            return allFactors;
        }
        
        // Get prime-blended HSL color for a pathway's ratio
        function getPrimeColor(pathway) {
            if (!pathway.n || !pathway.d) return CONFIG.colors[pathway.category] || '#666';
            
            const factors = getRatioFactors(pathway.n, pathway.d);
            const total = Object.values(factors).reduce((a, b) => a + b, 0);
            if (total === 0) return '#666';
            
            let h = 0, s = 0, l = 0;
            for (const [p, count] of Object.entries(factors)) {
                const col = CONFIG.primeColors[p] || CONFIG.primeColors.x;
                const weight = count / total;
                h += col.h * weight;
                s += col.s * weight;
                l += col.l * weight;
            }
            
            return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`;
        }

        // ===========================================
        // SUBCATEGORY DEFINITIONS
        // ===========================================
        const SUBCATEGORY_MAP = {
            energy: [
                { id: 'Glycolysis/Gluconeogenesis', label: 'Glycolysis', count: 4 },
                { id: 'TCA Cycle', label: 'TCA Cycle', count: 2 },
                { id: 'Pentose Phosphate', label: 'Pentose Phosphate', count: 3 },
                { id: 'Fermentation', label: 'Fermentation', count: 15 },
                { id: 'Glyoxylate Cycle', label: 'Glyoxylate', count: 2 },
                { id: 'Respiration', label: 'Respiration', count: 1 }
            ],
            biosynthesis: [
                { id: 'Nucleotides', label: 'Nucleotides', count: 7 },
                { id: 'Amino Acids', label: 'Amino Acids', count: 28 },
                { id: 'Fatty Acids/Lipids', label: 'Lipids', count: 17 },
                { id: 'Cofactors/Vitamins', label: 'Cofactors', count: 28 },
                { id: 'Cell Envelope', label: 'Cell Envelope', count: 24 },
                { id: 'Isoprenoids', label: 'Isoprenoids', count: 7 },
                { id: 'Polyamines', label: 'Polyamines', count: 6 },
                { id: 'Other', label: 'Other', count: 12 },
                { id: 'Specialized', label: 'Specialized', count: 14 }
            ],
            degradation: [
                { id: 'Other', label: 'Other', count: 81 },
                { id: 'Amino Acids', label: 'Amino Acids', count: 12 },
                { id: 'Nucleotides', label: 'Nucleotides', count: 9 },
                { id: 'Carbohydrates', label: 'Carbohydrates', count: 7 },
                { id: 'Aromatics', label: 'Aromatics', count: 5 }
            ],
            salvage: [
                { id: 'Salvage/Recycling', label: 'Salvage/Recycling', count: 15 }
            ],
            other: [
                { id: 'Unclassified', label: 'Unclassified', count: 50 }
            ],
            superpathways: [
                { id: 'Superpathways', label: 'Superpathways', count: 10 }
            ]
        };

        // ===========================================
        // FOCUS & CYCLING STATE
        // ===========================================
        let focusedCategory = null;
        
        // Multi-sequence support: Map of subcategory -> sequence state
        const activeSequences = new Map();  // key: "category:subcategory" -> { interval, index, pathways, tempo, btnElement }
        const BASE_SEQUENCE_TEMPO = 350;  // ms per pip base
        
        let activeCategory = 'energy';  // For subcategory display
        
        // Visual bounce for sequence
        const sequenceBounce = new Map();  // pathwayId -> bounce amount (0-1)
        
        // Solo mode for sequences (ducks drone)
        let sequenceSoloActive = false;
        
        // ===========================================
        // MS KEY FINDINGS STATE
        // ===========================================
        let activeFinding = null;  // Currently focused finding
        let findingPathways = new Set();  // Pathways in the active finding

        // ===========================================
        // ZOOM STATE - Range covers 1/8 to 16/1 (82.5Hz - 10560Hz at 660Hz fundamental)
        // ===========================================
        const ZOOM = {
            minFreq: 80,      // Just below 1/8 of 660Hz (82.5Hz)
            maxFreq: 11000,   // Just above 16/1 of 660Hz (10560Hz)
            defaultMin: 80,
            defaultMax: 11000,
            minRange: 100,
            zoomSpeed: 0.15
        };
        
        // Y-axis compression (subtle log-like scaling for low values)
        const Y_COMPRESSION = 0.7;  // < 1 compresses low values, > 1 expands them
        
        // Breathing animation (local time-based)
        let breathTime = 0;;

        // ===========================================
        // AUDIO STATE
        // ===========================================
        let audioContext = null, workletNode = null, masterGain = null, analyser = null, isPlaying = false;
        let modulationData = { time: 0, peristalsisPhase: 0, categoryPan: {}, pathways: new Map() };
        let focusedPathway = null, hoveredPathway = null, lastPipTime = 0;
        
        // ═══════════════════════════════════════════════════════════════════════
        // MS COMPARISON - Phase-Based Guided Attention System
        // ═══════════════════════════════════════════════════════════════════════
        // 
        // This is NOT a cinematic animation. It is a guided attention system.
        // Each phase answers ONE question:
        //   AFFECTED: "Which pathways differ?"
        //   DEPLETED: "Which are reduced in MS?"
        //   ELEVATED: "Which are elevated in MS?"
        //   SETTLED:  "Now see the full picture"
        //
        // Design principles:
        //   - Each phase modifies ONE primary visual channel
        //   - All values smoothed (no pops)
        //   - Variables have ONE meaning (no semantic overloading)
        //   - Fast enough to feel responsive (~1.5s total)
        //   - Restart-safe under rapid interaction
        // ═══════════════════════════════════════════════════════════════════════
        
        let msMode = false;
        
        // Phase progress values (each 0→1, independent)
        const msPhase = {
            affected: 0,    // Phase 1: Show which pathways are affected
            depleted: 0,    // Phase 2: Shrink depleted pathways  
            elevated: 0,    // Phase 3: Grow elevated pathways
            settled: 0,     // Phase 4: Final state emphasis
        };
        
        // Timing (in seconds) - keep SHORT for responsiveness
        const MS_PHASE_DURATION = {
            affected: 0.5,   // Quick identification
            depleted: 0.5,   // Direction reveal
            elevated: 0.5,   // Direction reveal  
            settled: 0.3,    // Settle into final state
            out: 1.5,        // Return to healthy (slower, gentler)
        };
        
        // Phase sequencing
        let msPhaseIndex = -1;  // -1=idle, 0=affected, 1=depleted, 2=elevated, 3=settled, 4=out
        let msPhaseStartTime = 0;
        let msOutCompleteTime = null;  // Track when OUT finished for graceful decay
        
        // Per-pathway smoothed states (the smoothing eliminates all pops)
        const msPathwayState = new Map();  // pathway.id -> { alpha, scale, width }
        
        // MS pathway classifications (populated on mode change)
        const MS_AFFECTED_PATHWAYS = new Set();
        const MS_DEPLETED_PATHWAYS = new Set();
        const MS_ELEVATED_PATHWAYS = new Set();
        
        // Key Finding state
        let findingEmphasis = 0;  // 0-1, smoothed
        
        // Visual cascade state (synced with audio)
        let visualCascade = {
            active: false,
            direction: 'in',
            startTime: 0,
            duration: 1.66,
            pathwayFade: new Map(),  // pathwayId -> fade (0-1)
        };

        // Pip settings
        const PIP_COOLDOWN = 80;
        const PIP_DURATION = 0.1;
        const PIP_VOLUME = 0.15;
        const SEQUENCE_PIP_DURATION = 0.1;
        const SEQUENCE_PIP_VOLUME = 0.1;
        const SEQUENCE_PIP_INTERVAL = 180;
        
        // Focus settings
        const FOCUS_BOOST_DB = 5;
        const FOCUS_DUCK_DB = -8;
        const FOCUS_MIN_VISUAL_HEIGHT = 0.25;
        
        // Category boost settings (when category is highlighted)
        const CATEGORY_BOOST_DB = 6;
        const CATEGORY_DUCK_DB = -6;
        
        let pipGain = null;
        const pathwayHoverIntensity = new Map();
        const HOVER_ATTACK = 0.25, HOVER_DECAY = 0.08;

        // ===========================================
        // PAN STATE
        // ===========================================
        let isPanning = false;
        let panStartX = 0;
        let panStartMinFreq = 0;
        let panStartMaxFreq = 0;

        // ===========================================
        // CACHED BAR POSITIONS
        // ===========================================
        let cachedBars = [];

        // ===========================================
        // DOM ELEMENTS
        // ===========================================
        const playBtn = document.getElementById('playBtn');
        const playIcon = document.getElementById('playIcon');
        const vizContainer = document.getElementById('vizContainer');
        const spectrumCanvas = document.getElementById('spectrumCanvas');
        const spectrumCtx = spectrumCanvas.getContext('2d');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const subcategoryFaders = document.getElementById('subcategoryFaders');
        const subcatIndicator = document.getElementById('subcatIndicator');
        const subcatLabel = document.getElementById('subcatLabel');
        
        // Oscilloscope - switches between desktop and mobile canvas
        let scopeCanvas, scopeCtx;
        const desktopScopeCanvas = document.getElementById('scopeCanvas');
        const mobileScopeCanvas = document.getElementById('mobileScopeCanvas');
        
        function updateActiveScope() {
            const isMobile = window.matchMedia('(max-width: 900px)').matches;
            const targetCanvas = isMobile ? mobileScopeCanvas : desktopScopeCanvas;
            
            // Only switch if we have a valid target
            if (!targetCanvas) {
                console.warn('Scope canvas not found, using fallback');
                scopeCanvas = desktopScopeCanvas;
            } else {
                scopeCanvas = targetCanvas;
            }
            
            if (scopeCanvas) {
                scopeCtx = scopeCanvas.getContext('2d', { willReadFrequently: true });
                resizeScopeCanvas();
                console.log('Active scope:', scopeCanvas.id, 'isMobile:', isMobile);
            }
        }
        
        function resizeScopeCanvas() {
            if (!scopeCanvas || !scopeCtx) return;
            
            const dpr = window.devicePixelRatio || 1;
            const rect = scopeCanvas.getBoundingClientRect();
            
            // If canvas has no size yet, try parent
            let width = rect.width;
            let height = rect.height;
            
            if (width === 0 || height === 0) {
                const parent = scopeCanvas.parentElement;
                if (parent) {
                    const parentRect = parent.getBoundingClientRect();
                    width = parentRect.width || 60;
                    height = parentRect.height || 40;
                }
            }
            
            if (width > 0 && height > 0) {
                scopeCanvas.width = width * dpr;
                scopeCanvas.height = height * dpr;
                scopeCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
        }
        
        // Initialize scope - may need to retry for mobile
        function initScope() {
            updateActiveScope();
            
            // Retry after a short delay for mobile layout
            setTimeout(updateActiveScope, 100);
            setTimeout(updateActiveScope, 500);
        }
        
        // Initialize on load
        if (document.readyState === 'complete') {
            initScope();
        } else {
            window.addEventListener('load', initScope);
        }
        
        // Switch canvas on resize
        window.addEventListener('resize', updateActiveScope);
        
        // Also update on orientation change (mobile)
        window.addEventListener('orientationchange', () => {
            setTimeout(updateActiveScope, 100);
        });

        // ===========================================
        // HELPERS
        // ===========================================
        function getEffectiveZoomRange() {
            // On mobile with active scrubber zoom, narrow the frequency range
            const isMobile = window.matchMedia('(max-width: 900px)').matches;
            if (isMobile && typeof scrubberZoom !== 'undefined' && scrubberZoom > 1 && scrubberX !== null) {
                // Get frequency at scrubber position (center of zoom)
                const minLog = Math.log10(ZOOM.minFreq);
                const maxLog = Math.log10(ZOOM.maxFreq);
                const fullRange = maxLog - minLog;
                
                // Narrow the range based on zoom level
                const zoomedRange = fullRange / scrubberZoom;
                
                // Center on scrubber X position
                const width = spectrumCanvas.width / (window.devicePixelRatio || 1);
                const xRatio = (scrubberX - 40) / (width - 60);
                const centerLog = minLog + xRatio * fullRange;
                
                const newMinLog = centerLog - zoomedRange / 2;
                const newMaxLog = centerLog + zoomedRange / 2;
                
                return {
                    minFreq: Math.pow(10, Math.max(newMinLog, Math.log10(20))),
                    maxFreq: Math.pow(10, Math.min(newMaxLog, Math.log10(20000)))
                };
            }
            return { minFreq: ZOOM.minFreq, maxFreq: ZOOM.maxFreq };
        }
        
        function freqToX(freq, width) {
            const zoom = getEffectiveZoomRange();
            const minLog = Math.log10(zoom.minFreq);
            const maxLog = Math.log10(zoom.maxFreq);
            const freqLog = Math.log10(freq);
            return 40 + ((freqLog - minLog) / (maxLog - minLog)) * (width - 60);
        }
        
        function xToFreq(x, width) {
            const zoom = getEffectiveZoomRange();
            const minLog = Math.log10(zoom.minFreq);
            const maxLog = Math.log10(zoom.maxFreq);
            const ratio = (x - 40) / (width - 60);
            return Math.pow(10, minLog + ratio * (maxLog - minLog));
        }
        
        function isZoomed() {
            return Math.abs(ZOOM.minFreq - ZOOM.defaultMin) > 1 || Math.abs(ZOOM.maxFreq - ZOOM.defaultMax) > 1;
        }
        
        function updateResetButton() {
            resetZoomBtn.classList.toggle('visible', isZoomed());
        }
        
        function isPathwayVisible(pathway) {
            const categoryGain = CONFIG.categoryGains[pathway.category] ?? 1.0;
            const subcategoryGain = CONFIG.subcategoryGains[pathway.subcategory] ?? 1.0;
            return categoryGain > 0.01 && subcategoryGain > 0.01;
        }

        // ===========================================
        // DYNAMIC SUBCATEGORY UI
        // ===========================================
        function updateSubcategoryUI(category) {
            // Don't stop sequences when switching view - allow cross-category sequences
            activeCategory = category;
            const subcats = SUBCATEGORY_MAP[category] || [];
            const color = CONFIG.colors[category] || '#666';
            
            subcatIndicator.style.background = color;
            subcategoryFaders.style.borderLeftColor = color;
            
            // Handle empty subcategories
            if (subcats.length === 0) {
                subcatLabel.textContent = category.charAt(0).toUpperCase() + category.slice(1) + ' (no subcategories)';
                subcategoryFaders.innerHTML = '';
                return;
            }
            
            subcatLabel.textContent = category.charAt(0).toUpperCase() + category.slice(1) + ' Subcategories';
            
            // Compact structure: [dot+label btn] [slider] - click btn to sequence
            subcategoryFaders.innerHTML = subcats.map(sub => `
                <div class="subcategory-fader" data-subcategory="${sub.id}" data-category="${category}">
                    <button class="subcat-btn" data-subcategory="${sub.id}" data-category="${category}">
                        <span class="dot" style="background:${color};"></span>
                        <span class="label">${sub.label}</span>
                    </button>
                    <input type="range" data-subcategory="${sub.id}" data-category="${category}" min="0" max="100" value="${Math.round((CONFIG.subcategoryGains[sub.id] ?? 1) * 100)}">
                </div>
            `).join('');
            
            attachSubcategoryListeners();
        }
        
        function attachSubcategoryListeners() {
            // Slider input
            document.querySelectorAll('.subcategory-fader input[type="range"]').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const subcat = e.target.dataset.subcategory;
                    const value = parseInt(e.target.value);
                    setSubcategoryGain(subcat, value / 100);
                });
                
                slider.addEventListener('dblclick', (e) => {
                    e.target.value = 100;
                    setSubcategoryGain(e.target.dataset.subcategory, 1.0);
                });
            });
            
            // Subcat button click - starts/stops sequence
            document.querySelectorAll('.subcategory-fader .subcat-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const fader = e.target.closest('.subcategory-fader');
                    const subcat = fader.dataset.subcategory;
                    const cat = fader.dataset.category;
                    const subcatBtn = fader.querySelector('.subcat-btn');
                    toggleSubcategoryCycle(subcat, cat, subcatBtn);
                });
            });
        }

        // ===========================================
        // SUBCATEGORY NAVIGATION (arrow buttons)
        // ===========================================
        const CATEGORY_ORDER = ['energy', 'biosynthesis', 'degradation', 'salvage', 'other'];
        
        function navigateSubcategory(direction) {
            const currentIndex = CATEGORY_ORDER.indexOf(activeCategory);
            let newIndex = currentIndex + direction;
            
            // Wrap around
            if (newIndex < 0) newIndex = CATEGORY_ORDER.length - 1;
            if (newIndex >= CATEGORY_ORDER.length) newIndex = 0;
            
            const newCategory = CATEGORY_ORDER[newIndex];
            activeCategory = newCategory;
            updateSubcategoryUI(newCategory);
        }
        
        // Attach nav button listener (once, not in attachSubcategoryListeners)
        document.getElementById('subcatNext').addEventListener('click', () => navigateSubcategory(1));

        // ===========================================
        // CATEGORY FOCUS (Audio boost + visual)
        // ===========================================
        function setFocusedCategory(category) {
            if (focusedCategory === category) {
                // Clicking same category - toggle off focus
                focusedCategory = null;
                document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('focused'));
                restoreCategoryGains();
                return;
            }
            
            // Switch focus without stopping sequences
            const hadCategoryFocus = focusedCategory !== null;
            focusedCategory = category;
            
            // Clear pathway focus (but keep sequences running)
            if (focusedPathway) {
                focusedPathway = null;
                if (workletNode) {
                    workletNode.port.postMessage({ type: 'setFocus', data: { id: null } });
                }
            }
            
            // Update UI
            document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('focused'));
            const btn = document.querySelector(`.category-fader[data-category="${category}"] .category-btn`);
            if (btn) btn.classList.add('focused');
            
            updateSubcategoryUI(category);
            
            // Send category boost to audio worklet
            applyCategoryBoost(category);
        }
        
        function applyCategoryBoost(category) {
            if (!workletNode) return;
            
            // Boost focused category, duck others
            const boostGain = Math.pow(10, CATEGORY_BOOST_DB / 20);
            const duckGain = Math.pow(10, CATEGORY_DUCK_DB / 20);
            
            for (const cat of Object.keys(CONFIG.categoryGains)) {
                const newGain = (cat === category) ? boostGain : duckGain;
                workletNode.port.postMessage({ 
                    type: 'setCategoryGain', 
                    data: { category: cat, gain: newGain } 
                });
            }
        }
        
        function restoreCategoryGains() {
            if (!workletNode) return;
            
            // Restore all category gains to their slider values
            for (const cat of Object.keys(CONFIG.categoryGains)) {
                workletNode.port.postMessage({ 
                    type: 'setCategoryGain', 
                    data: { category: cat, gain: CONFIG.categoryGains[cat] } 
                });
            }
        }
        
        function clearFocus() {
            const hadCategoryFocus = focusedCategory !== null;
            const hadPathwayFocus = focusedPathway !== null;
            
            focusedCategory = null;
            focusedPathway = null;
            stopAllSequences();
            document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('focused'));
            
            // Restore audio gains
            if (hadCategoryFocus) {
                restoreCategoryGains();
            }
            if (hadPathwayFocus && workletNode) {
                workletNode.port.postMessage({ type: 'setFocus', data: { id: null } });
            }
        }

        // ===========================================
        // MULTI-SEQUENCE SUBCATEGORY CYCLING
        // ===========================================
        function getSequenceKey(category, subcategory) {
            return `${category}:${subcategory}`;
        }
        
        function calculateTempo(pathwayCount) {
            // More pathways = slightly slower tempo for musicality
            // Creates natural polyrhythms when multiple sequences run
            const normalized = Math.max(4, Math.min(pathwayCount, 20));
            return BASE_SEQUENCE_TEMPO * (normalized / 8);  // 8 pathways = base tempo
        }
        
        function toggleSubcategoryCycle(subcategory, category, btnElement) {
            const key = getSequenceKey(category, subcategory);
            
            // If already running, stop it
            if (activeSequences.has(key)) {
                stopSequence(key);
                return;
            }
            
            // Start new sequence
            const pathways = getPathwaysInSubcategory(subcategory, category);
            if (pathways.length === 0) return;
            
            const tempo = calculateTempo(pathways.length);
            
            // Category color mapping
            const catColors = {
                energy: { color: '#22c55e', light: '#dcfce7' },
                biosynthesis: { color: '#3b82f6', light: '#dbeafe' },
                degradation: { color: '#ef4444', light: '#fee2e2' },
                salvage: { color: '#ca8a04', light: '#fef9c3' },
                other: { color: '#6b7280', light: '#f3f4f6' },
                superpathways: { color: '#8b5cf6', light: '#ede9fe' }
            };
            const colors = catColors[category] || catColors.other;
            
            // Style the button - fill with category color
            if (btnElement) {
                btnElement.classList.add('cycling');
                btnElement.style.setProperty('--pulse-duration', `${tempo}ms`);
                btnElement.style.setProperty('--cat-color', colors.color);
                btnElement.style.setProperty('--cat-color-light', colors.light);
            }
            
            // Create sequence state
            const seqState = {
                interval: null,
                index: 0,
                pathways: pathways,
                tempo: tempo,
                btnElement: btnElement,
                category: category,
                subcategory: subcategory
            };
            
            // Pip first one immediately
            sequencePathway(seqState);
            
            // Continue at calculated tempo
            seqState.interval = setInterval(() => {
                seqState.index = (seqState.index + 1) % seqState.pathways.length;
                sequencePathway(seqState);
            }, tempo);
            
            activeSequences.set(key, seqState);
            
            // Update stop-all button state
            const stopBtn = document.getElementById('stopAllBtn');
            if (stopBtn) stopBtn.classList.add('has-active');
        }
        
        function sequencePathway(seqState) {
            const pathway = seqState.pathways[seqState.index];
            if (!pathway) return;
            
            // Play pip and get volume-based bounce scale
            const bounceScale = playSequencePip(pathway) || 0.5;
            
            // Visual bounce proportional to pip volume
            sequenceBounce.set(pathway.id, 0.6 * bounceScale);
        }
        
        function stopSequence(key) {
            const seq = activeSequences.get(key);
            if (seq) {
                if (seq.interval) clearInterval(seq.interval);
                if (seq.btnElement) {
                    seq.btnElement.classList.remove('cycling');
                    seq.btnElement.style.removeProperty('--pulse-duration');
                    seq.btnElement.style.removeProperty('--cat-color');
                    seq.btnElement.style.removeProperty('--cat-color-light');
                }
                activeSequences.delete(key);
            }
            // Update stop-all button state
            const stopBtn = document.getElementById('stopAllBtn');
            if (stopBtn) stopBtn.classList.toggle('has-active', activeSequences.size > 0);
        }
        
        function stopAllSequences() {
            for (const key of activeSequences.keys()) {
                stopSequence(key);
            }
            sequenceBounce.clear();
            
            // Turn off solo when stopping all sequences
            sequenceSoloActive = false;
            const soloBtn = document.getElementById('soloAllBtn');
            if (soloBtn) soloBtn.classList.remove('active');
            if (workletNode) {
                workletNode.port.postMessage({
                    type: 'setDroneSolo',
                    data: { solo: false }
                });
            }
            
            // Update stop-all button state
            const stopBtn = document.getElementById('stopAllBtn');
            if (stopBtn) stopBtn.classList.remove('has-active');
        }
        
        function isSubcategoryCycling(category, subcategory) {
            return activeSequences.has(getSequenceKey(category, subcategory));
        }
        
        function getPathwaysInSubcategory(subcategory, category) {
            if (typeof PATHWAY_DATA === 'undefined') {
                console.log('PATHWAY_DATA undefined!');
                return [];
            }
            const results = PATHWAY_DATA.ALL_PATHWAYS.filter(p => 
                p.category === category && p.subcategory === subcategory && isPathwayVisible(p)
            );
            console.log(`getPathwaysInSubcategory('${subcategory}', '${category}'): found ${results.length} pathways`);
            if (results.length === 0) {
                // Debug: show what subcategories exist for this category
                const existingSubcats = [...new Set(PATHWAY_DATA.ALL_PATHWAYS.filter(p => p.category === category).map(p => p.subcategory))];
                console.log(`  Available subcategories for ${category}:`, existingSubcats);
            }
            return results;
        }

        // ===========================================
        // PATHWAY INFO UPDATE
        // ===========================================
        function updatePathwayInfo(pathway) {
            // Update pathway ID with category-colored background
            const pwdIdEl = document.getElementById('pwdId');
            const identityBox = document.getElementById('pwdIdentityBox');
            
            pwdIdEl.textContent = pathway.id;
            pwdIdEl.className = 'pathway-id ' + pathway.category;
            
            // Dynamic font size based on ID length
            if (pathway.id.length > 18) {
                pwdIdEl.classList.add('very-long-id');
            } else if (pathway.id.length > 12) {
                pwdIdEl.classList.add('long-id');
            }
            
            // Update identity box background
            identityBox.className = 'pathway-identity-box ' + pathway.category;
            
            document.getElementById('pwdName').textContent = pathway.name;
            
            // Category label (now separate from ID)
            document.getElementById('pwdCategory').textContent = pathway.category.toUpperCase();
            document.getElementById('pwdSubcat').textContent = pathway.subcategory || '—';
            
            // Abundance: mean relative abundance (usually 0.000x scale)
            const abd = pathway.abundance ?? pathway.mean_abundance ?? pathway.amplitude ?? null;
            document.getElementById('pwdAbundance').textContent =
                abd !== null
                    ? (abd < 0.001 ? abd.toExponential(1) : abd.toFixed(4))
                    : '—';

            // Prevalence: % of samples containing this pathway (0-100%)
            document.getElementById('pwdPrev').textContent = (pathway.prevalence * 100).toFixed(1) + '%';
            
            const ratio = pathway.ratio || [1, 1];
            const ratioValue = ratio[0] / ratio[1];
            const freq = CONFIG.fundamental * ratioValue;
            
            // Cents: 0-1200 range (mod 1200 to stay within one octave)
            let cents = 1200 * Math.log2(ratioValue);
            cents = ((cents % 1200) + 1200) % 1200;  // Ensure positive 0-1200
            
            document.getElementById('ratioValue').textContent = ratio[0] + '/' + ratio[1];
            document.getElementById('freqValue').textContent = Math.round(freq);
            document.getElementById('centsValue').textContent = Math.round(cents);
            document.getElementById('intervalValue').textContent = ratio[0] * ratio[1];
            
            // Sync mobile audio display
            const mobileRatio = document.getElementById('mobileRatio');
            const mobileHz = document.getElementById('mobileHz');
            const mobileCents = document.getElementById('mobileCents');
            if (mobileRatio) mobileRatio.textContent = ratio[0] + '/' + ratio[1];
            if (mobileHz) mobileHz.textContent = Math.round(freq);
            if (mobileCents) mobileCents.textContent = Math.round(cents);
            
            // Update pathway detail panel (bottom left)
            updatePathwayDetailPanel(pathway);
        }

 async function initAudio() {
    try {
        // Show loading state on play button
        const playBtn = document.getElementById('playBtn');
        const mobilePlayBtn = document.querySelector('.mobile-play-btn');
        if (playBtn) {
            playBtn.classList.add('loading');
            playBtn.disabled = true;
        }
        if (mobilePlayBtn) {
            mobilePlayBtn.classList.add('loading');
            mobilePlayBtn.disabled = true;
        }
        
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create nodes
        masterGain = audioContext.createGain();
        masterGain.gain.value = CONFIG.volume;
        
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        
        // Compressor for consistent levels
        const compressor = audioContext.createDynamicsCompressor();
        compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
        compressor.knee.setValueAtTime(12, audioContext.currentTime);
        compressor.ratio.setValueAtTime(8, audioContext.currentTime);
        compressor.attack.setValueAtTime(0.003, audioContext.currentTime);
        compressor.release.setValueAtTime(0.15, audioContext.currentTime);
        
        // Pip oscillator gain - connects to masterGain (not destination!)
        pipGain = audioContext.createGain();
        pipGain.gain.value = PIP_VOLUME;
        pipGain.connect(masterGain);  // ← FIXED: goes through master
        
        // Load worklet - use mobile version on mobile
        const isMobile = window.matchMedia('(max-width: 900px)').matches;
        const workletPath = isMobile 
            ? 'js/microbiome-sonification-v13mobile.js'
            : 'js/microbiome-sonification-v13.js';
        console.log('Loading worklet:', workletPath);
        
        await audioContext.audioWorklet.addModule(workletPath);
        workletNode = new AudioWorkletNode(audioContext, 'microbiome-sonification-processor', {
            numberOfInputs: 0,
            numberOfOutputs: 1,
            outputChannelCount: [2]
        });
        
        workletNode.port.onmessage = (e) => {
            if (e.data.type === 'modulation') {
                const d = e.data.data;
                const pathwaysMap = new Map();
                if (d.pathways) {
                    d.pathways.forEach(p => pathwaysMap.set(p.id, p));
                }
                modulationData = {
                    time: d.time,
                    pathways: pathwaysMap,
                    peristalsisPhase: d.peristalsisPhase || 0,
                    mmcPhase: d.mmcPhase || 'quiescent',
                    mmcProgress: d.mmcProgress || 0,
                    focusId: d.focusId,
                    focusEnvelope: d.focusEnvelope || 0,
                    engines: d.engines || {},
                    // Harmonic cloud visualization
                    harmonicCloud: d.harmonicCloud || { center: 1, density: 0 },
                    harmonicCloudRegions: d.harmonicCloudRegions || [],
                };
            }
        };
        
        if (typeof PATHWAY_DATA !== 'undefined') {
            workletNode.port.postMessage({
                type: 'init',
                data: {
                    pathways: PATHWAY_DATA.ALL_PATHWAYS.map(p => ({
                        id: p.id,
                        n: p.n,
                        d: p.d,
                        ratio: p.ratioValue,
                        amplitude: p.amplitude || p.prevalence,
                        prevalence: p.prevalence || 0.5,
                        category: p.category,
                        subcategory: p.subcategory
                    }))
                }
            });
        }

        // Send MS comparison data to worklet
        if (typeof PATHWAY_DATA !== 'undefined' && PATHWAY_DATA.MS_COMPARISON_DATA) {
            workletNode.port.postMessage({
                type: 'setMSComparison',
                data: { msData: PATHWAY_DATA.MS_COMPARISON_DATA }
            });
        }
        
        // ═══════════════════════════════════════════════════════════════
        // CLEAN AUDIO ROUTING - Everything → masterGain → analyser → out
        // ═══════════════════════════════════════════════════════════════
        //
        //  workletNode → compressor ─┐
        //                            ├→ masterGain → analyser → destination
        //  pipGain ──────────────────┘
        //
        // ═══════════════════════════════════════════════════════════════
        
        workletNode.connect(compressor);
        compressor.connect(masterGain);
        // pipGain already connected to masterGain above
        
        masterGain.connect(analyser);
        analyser.connect(audioContext.destination);
        
        // Restore play button
        const playBtnRestore = document.getElementById('playBtn');
        const mobilePlayBtnRestore = document.querySelector('.mobile-play-btn');
        if (playBtnRestore) {
            playBtnRestore.classList.remove('loading');
            playBtnRestore.disabled = false;
        }
        if (mobilePlayBtnRestore) {
            mobilePlayBtnRestore.classList.remove('loading');
            mobilePlayBtnRestore.disabled = false;
        }
        
        console.log('Audio initialized successfully (all sources → analyser)');
        return true;
    } catch (err) {
        console.error('Audio init error:', err);
        
        // Restore button on error too
        const playBtnErr = document.getElementById('playBtn');
        const mobilePlayBtnErr = document.querySelector('.mobile-play-btn');
        if (playBtnErr) {
            playBtnErr.classList.remove('loading');
            playBtnErr.disabled = false;
        }
        if (mobilePlayBtnErr) {
            mobilePlayBtnErr.classList.remove('loading');
            mobilePlayBtnErr.disabled = false;
        }
        
        return false;
    }
}
        
        // Standard hover pip
        function playPip(pathway) {
            if (!audioContext || !pipGain) return;
            
            // In MS mode, only pip on affected pathways
            if (msMode && !MS_AFFECTED_PATHWAYS.has(pathway.id)) return;
            
            const freq = CONFIG.fundamental * pathway.ratioValue;
            const osc = audioContext.createOscillator();
            const env = audioContext.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = freq;
            env.gain.setValueAtTime(PIP_VOLUME, audioContext.currentTime);
            env.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + PIP_DURATION);
            
            osc.connect(env);
            env.connect(pipGain);
            osc.start();
            osc.stop(audioContext.currentTime + PIP_DURATION + 0.1);
        }
        
        // Longer sequence pip with slight attack
        function playSequencePip(pathway) {
            if (!audioContext || !pipGain) return;
            
            // Get slider gain values
            const categoryGain = CONFIG.categoryGains[pathway.category] ?? 1.0;
            const subcategoryGain = CONFIG.subcategoryGains[pathway.subcategory] ?? 1.0;
            const sliderGain = categoryGain * subcategoryGain;
            
            // Calculate pip volume based on context
            let pipVolume = SEQUENCE_PIP_VOLUME * sliderGain;
            
            const msEnabled = CONFIG.currentView === 'ms';
            const isAffected = msEnabled && MS_AFFECTED_PATHWAYS.has(pathway.id);
            const inFocusedCategory = focusedCategory && pathway.category === focusedCategory;
            
            if (focusedCategory) {
                // Category focus is active
                if (inFocusedCategory) {
                    if (msEnabled && isAffected) {
                        pipVolume *= 1.2;
                    } else if (msEnabled && !isAffected) {
                        pipVolume *= 0.35;
                    }
                    // In focused category, no MS: full slider volume
                } else {
                    // NOT in focused category
                    if (msEnabled && isAffected) {
                        pipVolume *= 0.5;
                    } else {
                        pipVolume *= 0.2;
                    }
                }
            } else if (msEnabled) {
                // No category focus, but MS mode active
                if (isAffected) {
                    pipVolume *= 1.1;
                } else {
                    pipVolume *= 0.3;
                }
            }
            
            // Store for visual bounce scaling
            const bounceScale = pipVolume / SEQUENCE_PIP_VOLUME;
            
            const freq = CONFIG.fundamental * pathway.ratioValue;
            const osc = audioContext.createOscillator();
            const env = audioContext.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = freq;
            
            const now = audioContext.currentTime;
            env.gain.setValueAtTime(0, now);
            env.gain.linearRampToValueAtTime(pipVolume, now + 0.02);
            env.gain.setValueAtTime(pipVolume, now + 0.1);
            env.gain.exponentialRampToValueAtTime(0.001, now + SEQUENCE_PIP_DURATION);
            
            osc.connect(env);
            env.connect(pipGain);
            osc.start();
            osc.stop(now + SEQUENCE_PIP_DURATION + 0.1);
            
            // Return bounce scale for visual sync
            return bounceScale;
        }

        // ===========================================
        // FOCUS PATHWAY (with audio boost)
        // ===========================================
        function setFocusedPathway(pathway) {
            if (focusedPathway && focusedPathway.id === pathway.id) {
                updatePathwaySummary(pathway.id);
                // Unfocus
                focusedPathway = null;
                if (workletNode) {
                    workletNode.port.postMessage({ type: 'setFocus', data: { id: null } });
                }
                return;
            }
            
            // Clear category focus first
            if (focusedCategory) {
                focusedCategory = null;
                document.querySelectorAll('.category-dot').forEach(d => d.classList.remove('focused'));
                restoreCategoryGains();
            }
            stopAllSequences();
            
            focusedPathway = pathway;
            updatePathwayInfo(pathway);
            
            // Send focus to audio worklet
            if (workletNode) {
                workletNode.port.postMessage({ 
                    type: 'setFocus', 
                    data: { 
                        id: pathway.id,
                        boostDb: FOCUS_BOOST_DB,
                        duckDb: FOCUS_DUCK_DB
                    } 
                });
            }
        }
// metacyc summaries
        // Pathway summaries - will be loaded from pathway_summaries.js
        let PATHWAY_SUMMARIES = {};
        
        // Try to load pathway summaries
        function loadPathwaySummaries() {
            // Check if loaded via external script
            if (typeof window.PATHWAY_SUMMARIES !== 'undefined') {
                PATHWAY_SUMMARIES = window.PATHWAY_SUMMARIES;
                console.log(`Loaded ${Object.keys(PATHWAY_SUMMARIES).length} pathway summaries`);
            }
        }
        
        // Update the pathway summary panel
        function updatePathwayDetailPanel(pathway) {
            const textEl = document.getElementById('pathwaySummaryText');
            const linkEl = document.getElementById('pathwaySummaryLink');
            
            if (!textEl) return;
            
            const summary = PATHWAY_SUMMARIES[pathway.id];
            const summaryText = summary?.summary || null;
            
            if (summaryText) {
                textEl.textContent = summaryText;
            } else {
                textEl.textContent = 'No description available for this pathway.';
            }
            
            linkEl.href = `https://metacyc.org/META/NEW-IMAGE?object=${pathway.id}`;
            linkEl.style.display = 'inline-block';
        }
        
        // Clear pathway summary panel
        function clearPathwayDetailPanel() {
            const textEl = document.getElementById('pathwaySummaryText');
            const linkEl = document.getElementById('pathwaySummaryLink');
            
            if (textEl) textEl.textContent = 'Hover over a pathway to see its description from MetaCyc.';
            if (linkEl) linkEl.style.display = 'none';
        }

        async function fetchMetaCycSummary(pathwayId, maxLength = 220) {
  const url = `https://websvc.biocyc.org/getxml?META:${pathwayId}`;

  try {
    const res = await fetch(url);
    const text = await res.text();

    const parser = new DOMParser();
    const xml = parser.parseFromString(text, 'application/xml');

    const comment = xml.querySelector('comment');
    if (!comment || !comment.textContent) return null;

    let summary = comment.textContent.trim();

    if (summary.length > maxLength) {
      summary = summary.slice(0, maxLength).replace(/\s+\S*$/, '') + '…';
    }

    return summary;
  } catch (err) {
    console.warn('MetaCyc fetch failed:', err);
    return null;
  }
}

async function updatePathwaySummary(pathwayId) {
  const summaryEl = document.getElementById('summaryText');

  summaryEl.textContent = 'Loading pathway description…';

  const summary = await fetchMetaCycSummary(pathwayId);

  if (summary) {
    summaryEl.innerHTML = `
      ${summary}
      <a href="https://metacyc.org/pathway?orgid=META&id=${pathwayId}"
         target="_blank"
         class="learn-more">
        Learn more →
      </a>
    `;
  } else {
    summaryEl.innerHTML = `
      Pathway description available on MetaCyc.
      <a href="https://metacyc.org/pathway?orgid=META&id=${pathwayId}"
         target="_blank"
         class="learn-more">
        View details →
      </a>
    `;
  }
}

        // ===========================================
        // CONTROL HANDLERS
        // ===========================================
        
        // Handle both click and touch for mobile compatibility
        async function handlePlayToggle() {
            if (!audioContext) {
                const success = await initAudio();
                if (!success) {
                    alert('Could not initialize audio. Please check console for errors.');
                    return;
                }
            }
            
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            if (isPlaying) {
                // Fade out - cascade from dissonant to consonant (reverse), faster
                if (workletNode) {
                    workletNode.port.postMessage({ type: 'fadeOut', data: { duration: 0.8 } });
                }
                startVisualCascade('out', 0.8);
                isPlaying = false;
                clearFocus();
                playBtn.classList.remove('playing');
                playIcon.innerHTML = '<path d="M8 5v14l11-7z"/>';
                // Delay removing active class until fade completes
                setTimeout(() => {
                    if (!isPlaying) vizContainer.classList.remove('active');
                }, 850);
            } else {
                // Fade in - cascade from consonant to dissonant, "syrup pour"
                if (workletNode) {
                    workletNode.port.postMessage({ type: 'setMasterVolume', data: CONFIG.volume });
                    workletNode.port.postMessage({ type: 'fadeIn', data: { duration: 2.2 } });
                }
                startVisualCascade('in', 4.8);  // Slower, more organic
                isPlaying = true;
                playBtn.classList.add('playing');
                playIcon.innerHTML = '<path d="M6 4h4v16H6zM14 4h4v16h-4z"/>';
                vizContainer.classList.add('active');
            }
        }
        
        playBtn.addEventListener('click', handlePlayToggle);
        
        // Touch handler for mobile - prevents issues with touch-to-click delay
        playBtn.addEventListener('touchend', function(e) {
            e.preventDefault();
            handlePlayToggle();
        });
        
        function startVisualCascade(direction, duration) {
            if (typeof PATHWAY_DATA === 'undefined') return;
            
            // Sort by consonance (n*d)
            const sorted = [...PATHWAY_DATA.ALL_PATHWAYS].sort((a, b) => {
                const consA = (a.n || 1) * (a.d || 1);
                const consB = (b.n || 1) * (b.d || 1);
                return consA - consB;
            });
            
            visualCascade.active = true;
            visualCascade.direction = direction;
            visualCascade.startTime = performance.now();
            visualCascade.duration = duration * 1000;
            visualCascade.pathwayOrder = sorted.map(p => p.id);
            visualCascade.pathwayFade.clear();
            
            // Give each pathway a random phase offset for organic feel
            visualCascade.pathwayPhase = new Map();
            for (const p of PATHWAY_DATA.ALL_PATHWAYS) {
                visualCascade.pathwayFade.set(p.id, direction === 'in' ? 0 : 1);
                visualCascade.pathwayPhase.set(p.id, Math.random() * 0.15); // 0-15% random offset
            }
        }
        
        function updateVisualCascade() {
            if (!visualCascade.active) return;
            
            const elapsed = performance.now() - visualCascade.startTime;
            const progress = Math.min(1, elapsed / visualCascade.duration);
            const total = visualCascade.pathwayOrder?.length || 1;
            
            for (let i = 0; i < total; i++) {
                const id = visualCascade.pathwayOrder[i];
                const phaseOffset = visualCascade.pathwayPhase?.get(id) || 0;
                
                if (visualCascade.direction === 'in') {
                    // Staggered start + random phase offset
                    const startProgress = (i / total * 0.6) + phaseOffset;
                    const fadeProgress = Math.max(0, Math.min(1, (progress - startProgress) / 0.35));
                    visualCascade.pathwayFade.set(id, easeOutQuad(fadeProgress));
                } else {
                    // Reverse for fade out
                    const reverseI = total - 1 - i;
                    const startProgress = (reverseI / total * 0.1) + phaseOffset;
                    const fadeProgress = Math.max(0, Math.min(1, (progress - startProgress) / 0.45));
                    visualCascade.pathwayFade.set(id, 1 - easeInQuad(fadeProgress));
                }
            }
            
            if (progress >= 1) {
                visualCascade.active = false;
                for (const id of visualCascade.pathwayOrder) {
                    visualCascade.pathwayFade.set(id, visualCascade.direction === 'in' ? 1 : 0);
                }
            }
        }
        
        function easeOutQuad(t) { return t * (2 - t); }
        function easeInQuad(t) { return t * t; }
        
        function getVisualCascadeFade(pathwayId) {
            if (!visualCascade.active && visualCascade.pathwayFade.size === 0) return 1;
            return visualCascade.pathwayFade.get(pathwayId) ?? 1;
        }

        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('volumeValue').textContent = value + '%';
            CONFIG.volume = value / 100;
            if (masterGain) masterGain.gain.setTargetAtTime(CONFIG.volume, audioContext.currentTime, 0.05);
            if (workletNode && isPlaying) workletNode.port.postMessage({ type: 'setMasterVolume', data: CONFIG.volume });
        });
        
        document.getElementById('volumeSlider').addEventListener('dblclick', (e) => {
            e.target.value = 40;
            document.getElementById('volumeValue').textContent = '40%';
            CONFIG.volume = 0.4;
            if (masterGain) masterGain.gain.setTargetAtTime(CONFIG.volume, audioContext.currentTime, 0.05);
            if (workletNode && isPlaying) workletNode.port.postMessage({ type: 'setMasterVolume', data: CONFIG.volume });
        });

        document.getElementById('fundamentalSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('fundamentalValue').textContent = value + ' Hz';
            CONFIG.fundamental = value;
            if (workletNode) workletNode.port.postMessage({ type: 'setFundamental', data: value });
        });
        
        document.getElementById('fundamentalSlider').addEventListener('dblclick', (e) => {
            e.target.value = 660;
            document.getElementById('fundamentalValue').textContent = '660 Hz';
            CONFIG.fundamental = 660;
            if (workletNode) workletNode.port.postMessage({ type: 'setFundamental', data: 660 });
        });
        
        // Stop all sequences button
        const stopAllBtn = document.getElementById('stopAllBtn');
        stopAllBtn.addEventListener('click', () => {
            stopAllSequences();
            updateStopAllButton();
        });
        
        // Solo button - ducks drone to hear sequences clearly
        const soloAllBtn = document.getElementById('soloAllBtn');
        if (soloAllBtn) {
            soloAllBtn.addEventListener('click', () => {
                sequenceSoloActive = !sequenceSoloActive;
                soloAllBtn.classList.toggle('active', sequenceSoloActive);
                
                if (workletNode) {
                    workletNode.port.postMessage({
                        type: 'setDroneSolo',
                        data: { 
                            solo: sequenceSoloActive, 
                            duckAmount: 0.0  // Mute drone completely
                        }
                    });
                }
            });
        }
        
        function updateStopAllButton() {
            const hasActive = activeSequences.size > 0;
            stopAllBtn.classList.toggle('has-active', hasActive);
        }

        // Category faders
        document.querySelectorAll('.category-fader input[type="range"]').forEach(slider => {
            slider.addEventListener('input', (e) => {
                const category = e.target.dataset.category;
                const value = parseInt(e.target.value);
                CONFIG.categoryGains[category] = value / 100;
                
                // Always update worklet (focus boost is additive)
                setCategoryGain(category, value / 100);
                
                // Don't call updateSubcategoryUI or clearFocus on slider drag - too disruptive
            });
            
            slider.addEventListener('dblclick', (e) => {
                e.target.value = 100;
                const category = e.target.dataset.category;
                CONFIG.categoryGains[category] = 1.0;
                setCategoryGain(category, 1.0);
            });
        });

        // Category button clicks - focus category AND unmute if muted
        document.querySelectorAll('.category-fader .category-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const category = e.target.closest('.category-fader').dataset.category;
                unmuteCategory(category);  // Unmute when focusing
                setFocusedCategory(category);
            });
        });
        
        // Helper: Unmute a category (reusable)
        function unmuteCategory(category) {
            const faderRow = document.querySelector(`.category-fader[data-category="${category}"]`);
            const toggle = faderRow?.querySelector('.hide-toggle');
            if (toggle && toggle.classList.contains('hidden')) {
                toggle.classList.remove('hidden');
                faderRow.classList.remove('muted');
                CONFIG.hiddenCategories[category] = false;
                setCategoryGain(category, CONFIG.categoryGains[category]);
            }
        }
        
        // Hide toggle clicks - grey out category
        document.querySelectorAll('.category-fader .hide-toggle').forEach(toggle => {
            toggle.addEventListener('click', (e) => {
                e.stopPropagation();
                const faderRow = e.target.closest('.category-fader');
                const category = faderRow.dataset.category;
                
                // If category is focused, clear focus first then mute
                if (focusedCategory === category) {
                    clearFocus();
                }
                
                if (toggle.classList.contains('hidden')) {
                    // Unhide
                    toggle.classList.remove('hidden');
                    faderRow.classList.remove('muted');
                    CONFIG.hiddenCategories[category] = false;
                    setCategoryGain(category, CONFIG.categoryGains[category]);
                } else {
                    // Hide
                    toggle.classList.add('hidden');
                    faderRow.classList.add('muted');
                    CONFIG.hiddenCategories[category] = true;
                    setCategoryGain(category, 0);
                }
            });
        });
        
        // Slider interaction - update subcategory display AND unmute if muted
        document.querySelectorAll('.category-fader input[type="range"]').forEach(slider => {
            slider.addEventListener('mousedown', (e) => {
                const category = e.target.dataset.category;
                unmuteCategory(category);  // Unmute when interacting with slider
                updateSubcategoryUI(category);
            });
            
            slider.addEventListener('input', (e) => {
                const category = e.target.dataset.category;
                unmuteCategory(category);  // Also unmute on drag
            });
        });

        // ===========================================
        // MS KEY FINDINGS HANDLERS
        // ===========================================
        
        // Enable key findings when MS mode is activated
        function enableKeyFindings() {
            const section = document.getElementById('keyFindingsSection');
            const grid = document.getElementById('keyFindingsGrid');
            const status = document.getElementById('findingsStatus');
            
            section.classList.add('enabled');
            
            // Enable all finding buttons (desktop AND mobile)
            document.querySelectorAll('.key-finding-btn').forEach(btn => {
                btn.disabled = false;
                btn.classList.remove('disabled');
            });
        }
        
        // Disable key findings when healthy mode
        function disableKeyFindings() {
            const section = document.getElementById('keyFindingsSection');
            const grid = document.getElementById('keyFindingsGrid');
            
            section.classList.remove('enabled');
            
            // Disable all finding buttons (desktop AND mobile)
            document.querySelectorAll('.key-finding-btn').forEach(btn => {
                btn.disabled = true;
                btn.classList.add('disabled');
                btn.classList.remove('active');
            });
            
            // Clear any active finding
            clearFindingFocus();
        }
        
        // Focus a key finding - highlights ALL pathways in the finding
        function focusKeyFinding(findingId) {
            const finding = window.MS_KEY_FINDINGS?.[findingId];
            if (!finding) {
                console.warn('Finding not found:', findingId);
                return;
            }
            
            // Clear any existing focus
            clearPathwayFocus();
            clearFindingFocus();
            
            // Set active finding
            activeFinding = findingId;
            
            // Build pathway set from v6 structure (mode-aware)
            findingPathways = new Set();
            const pathwayIdArray = [];  // For audio
            const mode = (typeof currentMode !== 'undefined') ? currentMode : 'composed';
            
            // Get pathways from inference.pathways (handle both flat array and mode-specific object)
            if (finding.inference && finding.inference.pathways) {
                const pathwayList = Array.isArray(finding.inference.pathways)
                    ? finding.inference.pathways
                    : (finding.inference.pathways[mode] || finding.inference.pathways.composed || []);
                for (const p of pathwayList) {
                    findingPathways.add(p.id);
                    pathwayIdArray.push(p.id);
                }
            }
            
            // Also add Cantoni pathways if present (handle both flat array and mode-specific object)
            if (finding.cantoniPathways) {
                const cantoniList = Array.isArray(finding.cantoniPathways)
                    ? finding.cantoniPathways
                    : (finding.cantoniPathways[mode] || finding.cantoniPathways.composed || []);
                for (const id of cantoniList) {
                    if (!findingPathways.has(id)) {
                        findingPathways.add(id);
                        pathwayIdArray.push(id);
                    }
                }
            }
            
            // Send to audio worklet with finding ID for character selection
            if (workletNode && pathwayIdArray.length > 0) {
                workletNode.port.postMessage({
                    type: 'setKeyFinding',
                    data: { 
                        pathwayIds: pathwayIdArray,
                        findingId: findingId  // 'kynurenine', 'energy', or 'fermentation'
                    }
                });
            }
            
            // Update button states
            document.querySelectorAll('.key-finding-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.finding === findingId);
            });
            
            // Update pathway ID display with primary pathway
            const pathwayList = Array.isArray(finding.inference?.pathways)
                ? finding.inference.pathways
                : (finding.inference?.pathways?.[mode] || finding.inference?.pathways?.composed || []);
            const primaryId = pathwayList[0]?.id;
            if (primaryId) {
                const pathwayIdEl = document.getElementById('pathwayIdValue');
                if (pathwayIdEl) {
                    pathwayIdEl.textContent = primaryId;
                }
            }
            
            // Update study info panel
            updateStudyInfoPanel(finding);
            
            console.log(`Focused finding: ${finding.title} (${findingPathways.size} pathways)`);
        }
        
        // Update the summary panel with finding details
        function updateStudyInfoPanel(finding) {
            // Hide pathway summary and docs, show finding content
            document.getElementById('pathwaySummarySection').style.display = 'none';
            document.getElementById('docsSection').style.display = 'none';
            document.getElementById('findingContent').style.display = 'flex';
            document.getElementById('tierRefs').style.display = 'none';
            
            // Update finding header
            document.getElementById('findingTitle').textContent = finding.title;
            document.getElementById('findingExpansion').textContent = finding.expansion || '';
            document.getElementById('findingSubtitle').textContent = finding.subtitle;
            
            const closeBtn = document.getElementById('closeFindingBtn');
            if (closeBtn) closeBtn.style.display = 'inline';
            
            // Set color variable
            document.getElementById('findingContent').style.setProperty('--finding-color', finding.color);
            
            // Quote
            if (finding.quote) {
                document.getElementById('findingQuoteText').textContent = `"${finding.quote.text}"`;
                document.getElementById('findingCitation').innerHTML = 
                    `— <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC12471209/" target="_blank">${finding.quote.source}</a>`;
                document.querySelector('.finding-quote').style.display = 'block';
            } else {
                document.querySelector('.finding-quote').style.display = 'none';
            }
            
            // Metabolite chips
            const chipsContainer = document.getElementById('findingMetaboliteChips');
            if (finding.metabolites && finding.metabolites.length > 0) {
                let html = '';
                for (const m of finding.metabolites) {
                    const dirClass = m.dir === '↓' ? 'depleted' : 'elevated';
                    html += `<div class="metabolite-chip">
                        <span class="name">${m.name}</span>
                        <span class="dir ${dirClass}">${m.dir}</span>
                        <span class="p-val">p=${m.p}</span>
                    </div>`;
                }
                chipsContainer.innerHTML = html;
            }
            
            // Pathway chips (handle both flat array and mode-specific object)
            const pathwayContainer = document.getElementById('findingPathwayChips');
            if (pathwayContainer && finding.inference && finding.inference.pathways) {
                const mode = (typeof currentMode !== 'undefined') ? currentMode : 'composed';
                const pathwayList = Array.isArray(finding.inference.pathways)
                    ? finding.inference.pathways
                    : (finding.inference.pathways[mode] || finding.inference.pathways.composed || []);
                let html = '';
                for (const p of pathwayList) {
                    const dirClass = p.dir === '↓' ? 'depleted' : 'elevated';
                    html += `<div class="pathway-chip">
                        <span>${p.id}</span>
                        <span class="pathway-dir ${dirClass}">${p.dir}</span>
                    </div>`;
                }
                pathwayContainer.innerHTML = html;
            }
            
            // Clinical note
            if (finding.clinical) {
                document.getElementById('findingClinicalText').textContent = finding.clinical;
                document.querySelector('.finding-clinical').style.display = 'block';
            } else {
                document.querySelector('.finding-clinical').style.display = 'none';
            }
        }
        
        // Show MS comparison content (swaps docs section only)
        function showMSContent() {
            document.getElementById('healthyDocs').style.display = 'none';
            document.getElementById('msDocs').style.display = 'block';
            document.getElementById('findingContent').style.display = 'none';
            document.getElementById('pathwaySummarySection').style.display = 'block';
            document.getElementById('docsSection').style.display = 'block';
            document.getElementById('tierRefs').style.display = 'block';
        }
        
        // Show healthy gut content
        function showHealthyContent() {
            document.getElementById('healthyDocs').style.display = 'block';
            document.getElementById('msDocs').style.display = 'none';
            document.getElementById('findingContent').style.display = 'none';
            document.getElementById('pathwaySummarySection').style.display = 'block';
            document.getElementById('docsSection').style.display = 'block';
            document.getElementById('tierRefs').style.display = 'block';
        }
        
        // Clear finding focus
        function clearFindingFocus() {
            activeFinding = null;
            findingPathways.clear();
            
            // Clear audio key finding
            if (workletNode) {
                workletNode.port.postMessage({
                    type: 'setKeyFinding',
                    data: { pathwayIds: [] }
                });
            }
            
            // Clear button states
            document.querySelectorAll('.key-finding-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Return to appropriate content based on mode
            if (msMode) {
                showMSContent();
            } else {
                showHealthyContent();
            }
        }
        
        // Clear pathway focus helper
        function clearPathwayFocus() {
            if (focusedPathway) {
                focusedPathway = null;
                if (workletNode) {
                    workletNode.port.postMessage({ type: 'setFocus', data: { id: null } });
                }
            }
        }
        
        // Set up key finding button handlers
        document.querySelectorAll('.key-finding-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (btn.disabled) return;
                
                const findingId = btn.dataset.finding;
                if (activeFinding === findingId) {
                    // Toggle off if clicking same finding
                    clearFindingFocus();
                    clearPathwayFocus();
                } else {
                    focusKeyFinding(findingId);
                }
            });
        });
        
        // Close button handler (new ID)
        document.getElementById('closeSummaryBtn')?.addEventListener('click', () => {
            clearFindingFocus();
            clearPathwayFocus();
        });

        // Nav button handlers for MS mode
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const view = btn.dataset.view;
                
                // Update active button
                document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Clear any finding focus when switching views
                clearFindingFocus();
                clearPathwayFocus();
                
                // Set MS mode and enable/disable key findings
                if (view === 'ms') {
                    setMSMode(true);
                    enableKeyFindings();
                    showMSContent();
                } else if (view === 'healthy') {
                    setMSMode(false);
                    disableKeyFindings();
                    showHealthyContent();
                }
                
                CONFIG.currentView = view;
            });
        });

        function setCategoryGain(category, gain) {
            if (workletNode) workletNode.port.postMessage({ type: 'setCategoryGain', data: { category, gain } });
        }
        
        function setSubcategoryGain(subcategory, gain) {
            CONFIG.subcategoryGains[subcategory] = gain;
            if (workletNode) workletNode.port.postMessage({ type: 'setSubcategoryGain', data: { subcategory, gain } });
        }

        function setMSMode(enabled) {
            // If disabling, first deactivate any Key Finding
            if (!enabled && activeFinding) {
                setActiveFinding(null);
            }
            
            msMode = enabled;
            
            if (enabled) {
                // Start phase sequence: AFFECTED → DEPLETED → ELEVATED → SETTLED
                msPhaseIndex = 0;
                msPhaseStartTime = performance.now();
                
                // Reset phase progress
                msPhase.affected = 0;
                msPhase.depleted = 0;
                msPhase.elevated = 0;
                msPhase.settled = 0;
                
                // Clear per-pathway states (will rebuild with smoothing)
                msPathwayState.clear();
                
                // Build pathway classifications (with mode filtering)
                MS_AFFECTED_PATHWAYS.clear();
                MS_DEPLETED_PATHWAYS.clear();
                MS_ELEVATED_PATHWAYS.clear();
                
                if (typeof PATHWAY_DATA !== 'undefined' && PATHWAY_DATA.MS_COMPARISON_DATA) {
                    const msData = PATHWAY_DATA.MS_COMPARISON_DATA;
                    const mode = (typeof currentMode !== 'undefined') ? currentMode : 'composed';
                    for (const id of Object.keys(msData)) {
                        const info = msData[id];
                        // Skip if pathway has mode restriction and current mode doesn't match
                        if (info.modes && !info.modes.includes(mode)) {
                            continue;
                        }
                        MS_AFFECTED_PATHWAYS.add(id);
                        if (info.enrichedIn === 'healthy') {
                            MS_DEPLETED_PATHWAYS.add(id);
                        } else {
                            MS_ELEVATED_PATHWAYS.add(id);
                        }
                    }
                }
                console.log(`MS: Phase 0 (AFFECTED) - ${MS_AFFECTED_PATHWAYS.size} pathways`);
            } else {
                // Start OUT phase
                msPhaseIndex = 4;  // OUT
                msPhaseStartTime = performance.now();
                console.log('MS: Phase 4 (OUT)');
            }
            
            // Update audio
            if (workletNode && typeof PATHWAY_DATA !== 'undefined' && PATHWAY_DATA.MS_COMPARISON_DATA) {
                workletNode.port.postMessage({
                    type: 'setMSMode',
                    data: { 
                        enabled, 
                        msData: PATHWAY_DATA.MS_COMPARISON_DATA,
                    }
                });
            }
            
            // Update title
            const subtitle = document.querySelector('.app-subtitle');
            subtitle.textContent = enabled ? 'MS Microbiome Comparison' : 'The Human Gut Microbiome Sonified';
        }


        // ===========================================
        // CANVAS SETUP
        // ===========================================
        function resizeCanvases() {
            const rect = spectrumCanvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            spectrumCanvas.width = rect.width * dpr;
            spectrumCanvas.height = rect.height * dpr;
            spectrumCtx.scale(dpr, dpr);
            spectrumCanvas.style.width = rect.width + 'px';
            spectrumCanvas.style.height = rect.height + 'px';
            
            // Resize oscilloscope (uses the active canvas - desktop or mobile)
            resizeScopeCanvas();
        }

        // ===========================================
        // SPECTRUM VISUALIZATION
        // ===========================================
        function drawSpectrum() {
            const width = spectrumCanvas.width / (window.devicePixelRatio || 1);
            const height = spectrumCanvas.height / (window.devicePixelRatio || 1);
            
            // Background with subtle MMC phase indication
            const mmcPhase = modulationData.mmcPhase || 'quiescent';
            const bgTint = {
                quiescent: '#fafafa',
                mixing: '#f9fcf9',    // Very subtle green tint
                propulsive: '#fcfbf8', // Very subtle warm tint
            };
            
            // Dark mode backgrounds
            const darkBgTint = {
                quiescent: '#141414',
                mixing: '#141716',
                propulsive: '#161514',
            };
            
            const isDarkMode = CONFIG.currentMode === 'consonance';
            const bg = isDarkMode ? (darkBgTint[mmcPhase] || '#111') : (bgTint[mmcPhase] || '#fafafa');
            spectrumCtx.fillStyle = bg;
            spectrumCtx.fillRect(0, 0, width, height);
            
            // Update breath animation
            if (isPlaying) {
                breathTime += 0.05;  // Slow, gentle breathing
            }
            
            // Update visual cascade
            updateVisualCascade();
            
            // Decay sequence bounces
            for (const [id, bounce] of sequenceBounce) {
                sequenceBounce.set(id, bounce * 0.92);
                if (bounce < 0.01) sequenceBounce.delete(id);
            }
            
            // Grid
            spectrumCtx.strokeStyle = isDarkMode ? '#333' : '#f0f0f0';
            spectrumCtx.lineWidth = 1;
            const gridFreqs = [50, 100, 200, 500, 1000, 2000, 5000, 10000, 16000].filter(f => f >= ZOOM.minFreq && f <= ZOOM.maxFreq);
            gridFreqs.forEach(freq => {
                const x = freqToX(freq, width);
                if (x > 40 && x < width - 20) {
                    spectrumCtx.beginPath();
                    spectrumCtx.moveTo(x, 20);
                    spectrumCtx.lineTo(x, height - 30);
                    spectrumCtx.stroke();
                    spectrumCtx.fillStyle = isDarkMode ? '#666' : '#bbb';
                    spectrumCtx.font = '10px system-ui';
                    spectrumCtx.textAlign = 'center';
                    spectrumCtx.fillText(freq >= 1000 ? (freq/1000) + 'k' : freq.toString(), x, height - 12);
                }
            });
            
            // Fundamental marker
            const fundFreq = CONFIG.fundamental;
            if (fundFreq >= ZOOM.minFreq && fundFreq <= ZOOM.maxFreq) {
                const fundX = freqToX(fundFreq, width);
                spectrumCtx.strokeStyle = isDarkMode ? '#444' : '#ddd';
                spectrumCtx.setLineDash([4, 4]);
                spectrumCtx.beginPath();
                spectrumCtx.moveTo(fundX, 20);
                spectrumCtx.lineTo(fundX, height - 30);
                spectrumCtx.stroke();
                spectrumCtx.setLineDash([]);
                spectrumCtx.fillStyle = isDarkMode ? '#666' : '#999';
                spectrumCtx.font = '10px system-ui';
                spectrumCtx.textAlign = 'left';
                spectrumCtx.fillText('f₀=' + CONFIG.fundamental, fundX + 4, 32);
            }
            
            const maxBarHeight = height - 60;
            const baselineY = height - 30;
            
            cachedBars = [];
            
            if (typeof PATHWAY_DATA !== 'undefined') {
                // ═══════════════════════════════════════════════════════════════════════
                // MS COMPARISON - Phase-Based Guided Attention (once per frame)
                // ═══════════════════════════════════════════════════════════════════════
                
                const now = performance.now();
                const phaseElapsed = (now - msPhaseStartTime) / 1000;
                
                // Phase durations
                const D = MS_PHASE_DURATION;
                const phaseDurations = [D.affected, D.depleted, D.elevated, D.settled, D.out];
                const phaseNames = ['AFFECTED', 'DEPLETED', 'ELEVATED', 'SETTLED', 'OUT'];
                
                // Update current phase progress
                if (msPhaseIndex >= 0 && msPhaseIndex < 4) {
                    // IN phases (0-3)
                    const duration = phaseDurations[msPhaseIndex];
                    const progress = Math.min(phaseElapsed / duration, 1);
                    
                    // Update the appropriate phase
                    if (msPhaseIndex === 0) msPhase.affected = progress;
                    else if (msPhaseIndex === 1) msPhase.depleted = progress;
                    else if (msPhaseIndex === 2) msPhase.elevated = progress;
                    else if (msPhaseIndex === 3) msPhase.settled = progress;
                    
                    // Advance to next phase when complete
                    if (progress >= 1 && msPhaseIndex < 3) {
                        msPhaseIndex++;
                        msPhaseStartTime = now;
                        console.log(`MS: Phase ${msPhaseIndex} (${phaseNames[msPhaseIndex]})`);
                    }
                    
                } else if (msPhaseIndex === 4) {
                    // OUT phase - reverse everything
                    const outProgress = Math.min(phaseElapsed / D.out, 1);
                    const ease = 1 - Math.pow(1 - outProgress, 2);  // Ease out
                    
                    msPhase.affected = 1 - ease;
                    msPhase.depleted = 1 - ease;
                    msPhase.elevated = 1 - ease;
                    msPhase.settled = 1 - ease;
                    
                    if (outProgress >= 1) {
                        msPhaseIndex = -1;  // Idle
                        // DO NOT clear msPathwayState yet - let it decay naturally
                        msOutCompleteTime = performance.now();
                        console.log('MS: Idle (decaying)');
                    }
                }
                
                // After OUT complete: clear state only when visually gone
                if (msPhaseIndex === -1 && msOutCompleteTime) {
                    if (performance.now() - msOutCompleteTime > 800) {
                        msPathwayState.clear();
                        msOutCompleteTime = null;
                        console.log('MS: Fully reset');
                    }
                }
                
                // ═══════════════════════════════════════════════════════════════════════
                // SYNC MS PHASES TO AUDIO ENGINE (v10)
                // ═══════════════════════════════════════════════════════════════════════
                if (workletNode && (msPhaseIndex >= 0 || msPhase.affected > 0.01)) {
                    workletNode.port.postMessage({
                        type: 'setMSPhases',
                        data: {
                            phases: {
                                affected: msPhase.affected,
                                depleted: msPhase.depleted,
                                elevated: msPhase.elevated,
                                settled: msPhase.settled,
                            }
                        }
                    });
                }
                
                // Sort pathways: 
                // 1. Category priority (energy on top of biosynthesis, etc)
                // 2. Within category, low amplitude first so high amplitude draws ON TOP
                const CATEGORY_DRAW_ORDER = {
                    'superpathways': 0,  // Draw first (background)
                    'other': 1,
                    'salvage': 2,
                    'degradation': 3,
                    'biosynthesis': 4,
                    'energy': 5           // Draw last (foreground)
                };
                
                const sortedPathways = [...PATHWAY_DATA.ALL_PATHWAYS].sort((a, b) => {
                    // First by category (lower order = draw first)
                    const catA = CATEGORY_DRAW_ORDER[a.category] ?? 0;
                    const catB = CATEGORY_DRAW_ORDER[b.category] ?? 0;
                    if (catA !== catB) return catA - catB;
                    
                    // Within same category, lower amplitude first
                    const aAmp = (a.amplitude || a.prevalence || 0.5);
                    const bAmp = (b.amplitude || b.prevalence || 0.5);
                    return aAmp - bAmp;
                });
                
                sortedPathways.forEach((pathway) => {
                    const freq = CONFIG.fundamental * pathway.ratioValue;
                    if (freq < ZOOM.minFreq * 0.9 || freq > ZOOM.maxFreq * 1.1) return;
                    
                    const categoryGain = CONFIG.categoryGains[pathway.category] ?? 1.0;
                    const subcategoryGain = CONFIG.subcategoryGains[pathway.subcategory] ?? 1.0;
                    if (categoryGain < 0.01 || subcategoryGain < 0.01) return;
                    
                    // Get rich modulation data from worklet
                    const mod = modulationData.pathways.get(pathway.id) || { 
                        lfoMod: 1.0, envelope: 0, layer: null, shimmer: 0 
                    };
                    const x = freqToX(freq, width);
                    
                    // Layer-based state (what audio engine is this pathway in?)
                    const layer = mod.layer || null;
                    const isInDrone = layer === 'drone';
                    const isInCategory = layer === 'category';
                    const hasShimmer = (mod.shimmer || 0) > 0.1;
                    
                    const isFocused = focusedPathway && pathway.id === focusedPathway.id;
                    const isHovered = hoveredPathway && pathway.id === hoveredPathway.id;
                    const hasFocus = focusedPathway !== null;
                    const isCategoryHighlighted = focusedCategory === pathway.category;
                    const hasCategoryFocus = focusedCategory !== null;
                    const isInCyclingSubcat = isSubcategoryCycling(pathway.category, pathway.subcategory);
                    const bounce = sequenceBounce.get(pathway.id) || 0;
                    
                    // Key Finding highlight state
                    const isInFinding = activeFinding && findingPathways.has(pathway.id);
                    const hasFindingFocus = activeFinding !== null;
                    const finding = isInFinding && window.MS_KEY_FINDINGS ? window.MS_KEY_FINDINGS[activeFinding] : null;
                    const findingColor = finding?.color || null;
                    
                    let currentIntensity = pathwayHoverIntensity.get(pathway.id) || 0;
                    const targetIntensity = isHovered ? 1 : 0;
                    currentIntensity += (targetIntensity - currentIntensity) * (targetIntensity > currentIntensity ? HOVER_ATTACK : HOVER_DECAY);
                    if (currentIntensity < 0.01) currentIntensity = 0;
                    pathwayHoverIntensity.set(pathway.id, currentIntensity);
                    
                    // ═══════════════════════════════════════════════════════
                    // BASE AMPLITUDE - stable heights, layer-based alpha
                    // ═══════════════════════════════════════════════════════
                    let baseAmplitude = (pathway.amplitude || pathway.prevalence) * categoryGain * subcategoryGain;
                    
                    // Apply visual cascade fade
                    const cascadeFade = getVisualCascadeFade(pathway.id);
                    baseAmplitude *= cascadeFade;
                    
                    // Check if category is hidden (grey out mode)
                    const isHidden = CONFIG.hiddenCategories?.[pathway.category] || false;
                    
                    let visualScale = 1.0;
                    // Base alpha - lower so active pathways stand out more
                    const prevalenceAlpha = 0.25 + (pathway.prevalence || 0.5) * 0.4;  // 0.25 to 0.65
                    let alpha = prevalenceAlpha * cascadeFade;
                    // Line width proportional to amplitude (high amplitude = thicker, more visible)
                    const ampNorm = Math.pow(pathway.amplitude || pathway.prevalence || 0.5, 0.5);  // sqrt for gentle scaling
                    let lineWidth = 1.5 + ampNorm * 2.5;  // 1.5 to 4px range
                    let glowAmount = 0;
                    
                    // ═══════════════════════════════════════════════════════
                    // COLOR SELECTION - CONSONANCE-based intensity
                    // On light background: dark colors POP, light colors FADE
                    // LOW n×d = consonant = dark/bold (landmarks, grounded)
                    // HIGH n×d = dissonant = light/faded (easy to overlook)
                    // Gradient: [0]=dark, [1]=bold, [2]=bright, [3]=light
                    // ═══════════════════════════════════════════════════════
                    let useColor;
                    const gradients = CONFIG.colorGradients[pathway.category];
                    
                    if (gradients) {
                        // n×d is our consonance measure (lower = more consonant)
                        const nxd = pathway.ratio ? pathway.ratio[0] * pathway.ratio[1] : 100;
                        
                        // Map consonance to gradient index:
                        // Very consonant (n×d < 20) → dark (index 0) = stands out, grounded
                        // Consonant (n×d 20-100) → bold (index 1)
                        // Dissonant (n×d 100-500) → bright (index 2)
                        // Very dissonant (n×d > 500) → light (index 3) = fades away
                        let gradientIndex;
                        if (nxd < 20) {
                            gradientIndex = 0;  // dark = landmark, consonant
                        } else if (nxd < 100) {
                            gradientIndex = 1;  // bold/saturated  
                        } else if (nxd < 500) {
                            gradientIndex = 2;  // bright
                        } else {
                            gradientIndex = 3;  // light = dissonant, fades
                        }
                        useColor = gradients[gradientIndex];
                        
                        // Also reduce alpha for very dissonant (compound fading)
                        if (nxd > 200) {
                            const fadeFactor = Math.min(1, 200 / nxd);  // fades from 1.0 at 200 to 0.4 at 500
                            alpha *= 0.4 + fadeFactor * 0.6;
                        }
                    } else {
                        useColor = CONFIG.colors[pathway.category] || '#666';
                    }
                    
                    // Hidden category: grey out
                    if (isHidden) {
                        useColor = CONFIG.currentMode === 'consonance' ? '#444' : '#ccc';
                        alpha *= 0.4;
                    }
                    
                    // Subtle organism breathing (barely perceptible)
                    if (isPlaying && !isHidden) {
                        const pathwayOffset = (pathway.ratioValue * 1.5) % (Math.PI * 2);
                        const breathAmount = Math.sin(breathTime * 0.4 + pathwayOffset) * 0.015;
                        visualScale += breathAmount;
                    }
                    
                    // ═══════════════════════════════════════════════════════
                    // AUDIO-VISUAL SYNC - More dramatic for clarity
                    // When a pathway is sounding, it should CLEARLY pulse
                    // ═══════════════════════════════════════════════════════
                    if (isPlaying && !hasFindingFocus && !isHidden) {
                        if (isInDrone) {
                            // Drone layer: steady glow, moderate thickening
                            alpha += 0.2;
                            lineWidth += 1;
                            visualScale += 0.05;
                            glowAmount = 0.2;
                        }
                        if (isInCategory) {
                            // Category sweep: strong pulse with envelope
                            const envPow = Math.pow(mod.envelope, 0.7);  // Soften curve
                            alpha += envPow * 0.4;
                            lineWidth += envPow * 2.5;
                            visualScale += envPow * 0.15;
                            glowAmount = envPow * 0.5;
                        }
                        if (hasShimmer) {
                            // Shimmer: bright flash
                            alpha += mod.shimmer * 0.5;
                            visualScale += mod.shimmer * 0.1;
                            glowAmount = Math.max(glowAmount, mod.shimmer * 0.7);
                        }
                    }
                    
                    // ═══════════════════════════════════════════════════════════════════════
                    // HARMONIC CLOUD - Subtle glow based on cloud activity in this region
                    // The cloud is imperceptible individually but creates regional warmth
                    // ═══════════════════════════════════════════════════════════════════════
                    if (isPlaying && modulationData.harmonicCloudRegions) {
                        const regions = modulationData.harmonicCloudRegions;
                        const pathwayRegion = Math.round(Math.log2(pathway.ratioValue || 1) * 4);
                        
                        for (const region of regions) {
                            // Check if pathway is in or near this active region
                            if (Math.abs(region.region - pathwayRegion) <= 1) {
                                const intensity = Math.min(region.activity * 0.3, 0.15);
                                
                                // Very subtle alpha warmth
                                alpha += intensity;
                                
                                // Tiny glow for active regions
                                glowAmount = Math.max(glowAmount, intensity * 0.5);
                            }
                        }
                    }
                    
                    // ═══════════════════════════════════════════════════════════════════════
                    // MS COMPARISON - Phase-Based Per-Pathway Visual Changes
                    // Each phase modifies ONE primary channel (no conflating):
                    //   AFFECTED: alpha + width (group membership)
                    //   DEPLETED: scale ↓ (direction)
                    //   ELEVATED: scale ↑ (direction)  
                    //   SETTLED: final emphasis
                    // ALL changes smoothed to eliminate pops
                    // ═══════════════════════════════════════════════════════════════════════
                    
                    const msData = PATHWAY_DATA.MS_COMPARISON_DATA;
                    const msInfo = msData ? msData[pathway.id] : null;
                    const isAffected = MS_AFFECTED_PATHWAYS.has(pathway.id);
                    const isDepleted = MS_DEPLETED_PATHWAYS.has(pathway.id);
                    const isElevated = MS_ELEVATED_PATHWAYS.has(pathway.id);
                    const ldaScore = msInfo?.ldaScore || 0.5;
                    
                    // Get or create smoothed state for this pathway
                    let pState = msPathwayState.get(pathway.id);
                    if (!pState) {
                        pState = { alpha: 0, scale: 0, width: 0, dot: 0 };
                        msPathwayState.set(pathway.id, pState);
                    }
                    
                    // Calculate TARGET values based on phase progress
                    let targetAlpha = 0;
                    let targetScale = 0;
                    let targetWidth = 0;
                    let targetDot = 0;
                    
                    // Only apply if any phase is active
                    if (msPhaseIndex >= 0 || msPhase.affected > 0) {
                        
                        if (isAffected) {
                            // ── AFFECTED PATHWAYS ────────────────────────────
                            
                            // Phase 1 (AFFECTED): Brighten + thicken to show "these differ"
                            targetAlpha = msPhase.affected * 0.35;
                            targetWidth = msPhase.affected * 1.5;
                            
                            // Phase 2 (DEPLETED): Shrink height
                            if (isDepleted) {
                                targetScale = -ldaScore * 0.35 * msPhase.depleted;
                                targetDot = msPhase.depleted;  // Red dot appears
                            }
                            
                            // Phase 3 (ELEVATED): Grow height
                            if (isElevated) {
                                targetScale = ldaScore * 0.5 * msPhase.elevated;
                                targetDot = msPhase.elevated;  // Green dot appears
                                
                                // Extra boost for small pathways
                                const baseAmp = pathway.amplitude || pathway.prevalence || 0.5;
                                if (baseAmp < 0.4) {
                                    const boost = (0.4 - baseAmp) * 2.5;
                                    targetScale += boost * msPhase.elevated;
                                }
                            }
                            
                            // Phase 4 (SETTLED): Maintain emphasis
                            if (msPhase.settled > 0) {
                                targetAlpha = 0.25;  // Settled emphasis
                                targetWidth = 1.0;
                            }
                            
                        } else {
                            // ── NON-AFFECTED PATHWAYS ────────────────────────
                            // Duck during comparison (negative alpha = dimming)
                            targetAlpha = -msPhase.affected * 0.6;
                            targetWidth = -msPhase.affected * 0.5;
                            
                            // Extra duck during DEPLETED and ELEVATED phases
                            if (msPhase.depleted > 0 || msPhase.elevated > 0) {
                                const maxDepleteElevate = Math.max(msPhase.depleted, msPhase.elevated);
                                targetAlpha = Math.min(targetAlpha, -0.7 * maxDepleteElevate);
                            }
                            
                            // Settled: partial return
                            if (msPhase.settled > 0) {
                                targetAlpha = -0.4;
                            }
                        }
                    }
                    
                    // SMOOTH all values (this eliminates pops)
                    const smooth = 0.12;  // Smoothing factor
                    pState.alpha += (targetAlpha - pState.alpha) * smooth;
                    pState.scale += (targetScale - pState.scale) * smooth;
                    pState.width += (targetWidth - pState.width) * smooth;
                    pState.dot += (targetDot - pState.dot) * smooth;
                    
                    // After OUT complete: let residual state decay gracefully (no pop)
                    if (msPhaseIndex === -1 && msOutCompleteTime) {
                        const decay = 0.96;  // Slower decay for smoother blend
                        pState.alpha *= decay;
                        pState.scale *= decay;
                        pState.width *= decay;
                        pState.dot *= decay;
                    }
                    
                    // APPLY smoothed values
                    alpha = Math.max(0.05, Math.min(1, alpha + pState.alpha));
                    baseAmplitude *= (1 + pState.scale);
                    lineWidth = Math.max(1, lineWidth + pState.width);
                    
                    // Dot indicator
                    const dotOpacity = pState.dot;
                    
                    // ═══════════════════════════════════════════════════════════════════════
                    // KEY FINDING EMPHASIS
                    // Strategy: Reduce noise around finding pathways
                    // Kynurenine gets subtle breathing effect (neurotoxicity cue)
                    // ═══════════════════════════════════════════════════════════════════════
                    if (hasFindingFocus) {
                        const finding = window.MS_KEY_FINDINGS?.[activeFinding];
                        const fColor = finding?.color || '#3b82f6';
                        const now = performance.now();
                        
                        if (isInFinding) {
                            // This pathway is part of the finding
                            useColor = fColor;
                            alpha = 1.0;
                            lineWidth += 2;
                            visualScale += 0.1;
                            baseAmplitude *= 1.15;
                            
                            // Kynurenine: subtle breathing effect (neurotoxicity cue)
                            if (activeFinding === 'kynurenine') {
                                // Slow breath: 4 second cycle
                                const breath = Math.sin(now / 2000 * Math.PI) * 0.5 + 0.5;
                                alpha = 0.85 + breath * 0.15;
                                lineWidth += breath * 1.5;
                                visualScale += breath * 0.05;
                            }
                        } else {
                            // Not in finding - reduce to make finding pathways stand out
                            alpha *= 0.3;
                            lineWidth = Math.max(1, lineWidth * 0.6);
                        }
                    }
                    
                    // ═══════════════════════════════════════════════════════════════════════
                    // FOCUS / HOVER / CATEGORY STATES
                    // ═══════════════════════════════════════════════════════════════════════
                    if (isFocused) { 
                        visualScale = 1.3; alpha = 1.0; lineWidth = 4; 
                        baseAmplitude = Math.max(baseAmplitude, FOCUS_MIN_VISUAL_HEIGHT); 
                    } else if (hasFocus) { 
                        alpha *= 0.35; lineWidth = 1.5; 
                    }
                    
                    // ═══════════════════════════════════════════════════════════════════════
                    // MS + CATEGORY FOCUS INTERSECTION
                    // When both MS comparison and category focus are active,
                    // show focused category but emphasize MS-affected pathways
                    // ═══════════════════════════════════════════════════════════════════════
                    const msEnabled = CONFIG.currentView === 'ms';
                    
                    if (hasCategoryFocus && !hasFocus) {
                        if (isCategoryHighlighted) {
                            // This pathway is in the focused category
                            if (msEnabled && isAffected) {
                                // MS-affected pathway in focused category - FULL EMPHASIS
                                alpha = 1.0; 
                                lineWidth = 3.5; 
                                visualScale = 1.1;
                                if (isDepleted) {
                                    alpha = 0.95;
                                } else if (isElevated) {
                                    alpha = 1.0;
                                    lineWidth = 4;
                                }
                            } else if (msEnabled && !isAffected) {
                                // Non-MS pathway in focused category - reduced but visible
                                alpha = 0.5; 
                                lineWidth = 2;
                            } else {
                                // No MS comparison - normal category focus
                                alpha = 0.9; 
                                lineWidth = 2.5; 
                                visualScale = 1.05;
                            }
                        } else {
                            // Not in focused category - dimmed but still visible
                            alpha = 0.35; 
                            lineWidth = 1.5;
                        }
                    }
                    
                    if (isInCyclingSubcat && !hasFocus && !hasCategoryFocus) {
                        alpha = 0.9; lineWidth = 2.5;
                    }
                    
                    if (bounce > 0) {
                        visualScale += bounce * 0.5;
                        lineWidth += bounce * 3;
                        alpha = Math.min(1, alpha + bounce * 0.3);
                    }
                    
                    if (currentIntensity > 0 && !isFocused) { 
                        visualScale += currentIntensity * 0.15; 
                        alpha = Math.min(1, alpha + currentIntensity * 0.3); 
                        lineWidth += currentIntensity; 
                    }
                    
                    // ═══════════════════════════════════════════════════════
                    // DRAW BAR (with Y compression for better low-value visibility)
                    // ═══════════════════════════════════════════════════════
                    // Apply Y compression: pow < 1 boosts low values, making subtle differences visible
                    const compressedAmplitude = Math.pow(baseAmplitude, Y_COMPRESSION);
                    let barHeight = Math.min(compressedAmplitude * visualScale * (height - 80), maxBarHeight);
                    const color = useColor;  // Uses finding color when focused, category color otherwise
                    
                    cachedBars.push({
                        pathway, x,
                        top: baselineY - barHeight,
                        bottom: baselineY,
                        width: lineWidth + 6
                    });
                    
                    spectrumCtx.strokeStyle = color;
                    spectrumCtx.lineWidth = lineWidth;
                    spectrumCtx.globalAlpha = alpha;
                    spectrumCtx.beginPath();
                    spectrumCtx.moveTo(x, baselineY);
                    spectrumCtx.lineTo(x, baselineY - barHeight);
                    spectrumCtx.stroke();
                    
                    // Subtle glow for active pathways (audio-visual sync)
                    if (glowAmount > 0.1 && isPlaying && !isHidden) {
                        spectrumCtx.save();
                        spectrumCtx.strokeStyle = color;
                        spectrumCtx.lineWidth = lineWidth + glowAmount * 2;
                        spectrumCtx.globalAlpha = glowAmount * 0.2;
                        spectrumCtx.beginPath();
                        spectrumCtx.moveTo(x, baselineY);
                        spectrumCtx.lineTo(x, baselineY - barHeight);
                        spectrumCtx.stroke();
                        spectrumCtx.restore();
                    }
                    
                    // MS indicator dot - visible, clear colors
                    // Dot opacity should match bar alpha to maintain visual cohesion
                    if (isAffected && dotOpacity > 0.02) {
                        spectrumCtx.save();
                        
                        // Start with bar's alpha - dots should match bar visibility
                        let dotAlpha = Math.min(alpha, dotOpacity * 0.85);
                        
                        // If bar is very dim, dot should also be dim
                        if (alpha < 0.4) {
                            dotAlpha = alpha * 0.8;
                        }
                        
                        // Respect focus states (apply same reductions as bar)
                        if (hasFocus && !isFocused) {
                            dotAlpha *= 0.4;
                        }
                        if (hasFindingFocus && !isInFinding) {
                            dotAlpha *= 0.4;
                        }
                        if (hasCategoryFocus && !isCategoryHighlighted) {
                            dotAlpha *= 0.25;  // Match bar dimming
                        }
                        
                        spectrumCtx.globalAlpha = dotAlpha;
                        
                        // Color based on direction
                        if (isDepleted) {
                            spectrumCtx.fillStyle = '#dc2626';  // Red
                        } else if (msInfo?.enrichedIn === 'dysregulated') {
                            spectrumCtx.fillStyle = '#8b5cf6';  // Purple (kynurenine)
                        } else {
                            spectrumCtx.fillStyle = '#16a34a';  // Green
                        }
                        
                        spectrumCtx.beginPath();
                        spectrumCtx.arc(x, baselineY - barHeight - 4, 2, 0, Math.PI * 2);
                        spectrumCtx.fill();
                        spectrumCtx.restore();
                    }
                    
                    // Focus ring
                    if (isFocused) {
                        spectrumCtx.save();
                        spectrumCtx.strokeStyle = color;
                        spectrumCtx.lineWidth = 2;
                        spectrumCtx.globalAlpha = 0.9;
                        spectrumCtx.shadowColor = color;
                        spectrumCtx.shadowBlur = 12;
                        spectrumCtx.beginPath();
                        spectrumCtx.arc(x, baselineY - barHeight, 8, 0, Math.PI * 2);
                        spectrumCtx.stroke();
                        spectrumCtx.restore();
                    }
                    
                    spectrumCtx.globalAlpha = 1;
                });
            }
            
            // ═══════════════════════════════════════════════════════════════════════
            // MOBILE SCRUBBER - Draw scrubber line when active
            // ═══════════════════════════════════════════════════════════════════════
            const isMobile = window.matchMedia('(max-width: 900px)').matches;
            if (isMobile && typeof isScrubbing !== 'undefined') {
                // Animate zoom
                const targetZoom = isScrubbing ? SCRUB_ZOOM : 1;
                if (typeof scrubberZoom !== 'undefined') {
                    scrubberZoom += (targetZoom - scrubberZoom) * ZOOM_SPEED;
                }
                
                // Draw scrubber line when active
                if (isScrubbing && scrubberX !== null) {
                    spectrumCtx.save();
                    
                    // Vertical line - rich red, thin
                    spectrumCtx.strokeStyle = '#dc2626';
                    spectrumCtx.lineWidth = 1;
                    spectrumCtx.setLineDash([]);
                    spectrumCtx.beginPath();
                    spectrumCtx.moveTo(scrubberX, 0);
                    spectrumCtx.lineTo(scrubberX, height);
                    spectrumCtx.stroke();
                    
                    spectrumCtx.restore();
                }
            }
            
            // Peristalsis wave
            if (isPlaying) {
                // Peristalsis wave - intensity varies with MMC phase
                const waveY = height - 15;
                const mmcActivity = modulationData.mmcActivity?.peristalsis || 0.3;
                const waveAlpha = 0.15 + mmcActivity * 0.3;
                const waveAmplitude = 3 + mmcActivity * 4;
                spectrumCtx.strokeStyle = `rgba(34, 197, 94, ${waveAlpha})`;
                spectrumCtx.lineWidth = 1.5 + mmcActivity;
                spectrumCtx.beginPath();
                for (let i = 0; i < width; i++) {
                    const phase = (modulationData.peristalsisPhase || 0) + (i / width) * Math.PI * 2;
                    const y = waveY + Math.sin(phase) * waveAmplitude;
                    if (i === 0) spectrumCtx.moveTo(i, y); else spectrumCtx.lineTo(i, y);
                }
                spectrumCtx.stroke();
            }
            
            requestAnimationFrame(drawSpectrum);
        }

        // ===========================================
        // HIT DETECTION
        // ===========================================
        function findPathwayAtPoint(mouseX, mouseY) {
            let closest = null;
            let closestDist = Infinity;
            
            for (const bar of cachedBars) {
                if (mouseY < bar.top || mouseY > bar.bottom) continue;
                const xDist = Math.abs(bar.x - mouseX);
                if (xDist < bar.width / 2 && xDist < closestDist) {
                    if (isPathwayVisible(bar.pathway)) {
                        // During MS mode, only MS-affected pathways are interactable
                        if (msMode && !MS_AFFECTED_PATHWAYS.has(bar.pathway.id)) {
                            continue;  // Skip non-MS pathways
                        }
                        closestDist = xDist;
                        closest = bar.pathway;
                    }
                }
            }
            return closest;
        }

// ===========================================
// SPECTROGRAPH + WAVEFORM OVERLAY
// ===========================================

function drawOscilloscope() {
    if (!scopeCanvas || !scopeCtx) {
        requestAnimationFrame(drawOscilloscope);
        return;
    }
    
    const dpr = window.devicePixelRatio || 1;
    const width = scopeCanvas.width / dpr;
    const height = scopeCanvas.height / dpr;
    
    // Detect if we're on mobile (dark bg) or desktop (light bg)
    const isMobile = window.matchMedia('(max-width: 900px)').matches;
    
    if (!isPlaying || !analyser) {
        // Idle state
        if (isMobile) {
            scopeCtx.fillStyle = '#111';
            scopeCtx.fillRect(0, 0, width, height);
            scopeCtx.strokeStyle = '#333';
        } else {
            scopeCtx.fillStyle = '#fff';
            scopeCtx.fillRect(0, 0, width, height);
            scopeCtx.strokeStyle = '#ddd';
        }
        scopeCtx.lineWidth = 1;
        scopeCtx.beginPath();
        scopeCtx.moveTo(0, height / 2);
        scopeCtx.lineTo(width, height / 2);
        scopeCtx.stroke();
        
        requestAnimationFrame(drawOscilloscope);
        return;
    }
    
    // Draw spectrograph
    drawSpectrograph(width, height, isMobile);
    
    // Overlay waveform when focused (on both desktop and mobile)
    if (focusedPathway) {
        drawWaveformOverlay(width, height, isMobile);
    }
    
    requestAnimationFrame(drawOscilloscope);
}

// ===========================================
// SPECTROGRAPH (base layer)
// ===========================================
function drawSpectrograph(width, height, isMobile = false) {
    if (!analyser) {
        console.log('No analyser');
        return;
    }
    
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    analyser.getByteFrequencyData(dataArray);
    
    const sampleRate = audioContext.sampleRate;
    const fundamental = CONFIG.fundamental || 660;
    const binSize = sampleRate / (bufferLength * 2);
    
    // Narrower range for mobile (smaller display)
    const minRatio = isMobile ? 1 / 4 : 1 / 8;
    const maxRatio = isMobile ? 8 : 16;
    const minFreq = fundamental * minRatio;
    const maxFreq = fundamental * maxRatio;
    
    // Mobile: simple bar visualization (no scrolling spectrogram)
    if (isMobile) {
        // Clear with dark background
        scopeCtx.fillStyle = '#111';
        scopeCtx.fillRect(0, 0, width, height);
        
        // Draw frequency bars
        const numBars = Math.min(width, 30);
        const barWidth = width / numBars;
        
        for (let i = 0; i < numBars; i++) {
            const normalizedX = i / numBars;
            const logMin = Math.log2(minFreq);
            const logMax = Math.log2(maxFreq);
            const freq = Math.pow(2, logMin + normalizedX * (logMax - logMin));
            
            const binIndex = Math.round(freq / binSize);
            let value = 0;
            if (binIndex >= 0 && binIndex < bufferLength) {
                value = dataArray[binIndex];
            }
            
            const barHeight = (value / 255) * height * 0.9;
            const brightness = Math.floor(150 + (value / 255) * 105);
            
            scopeCtx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
            scopeCtx.fillRect(
                i * barWidth + 1, 
                height - barHeight, 
                barWidth - 1, 
                barHeight
            );
        }
        return;
    }
    
    // Desktop: scrolling spectrogram
    const imageData = scopeCtx.getImageData(1, 0, width - 1, height);
    scopeCtx.putImageData(imageData, 0, 0);
    
    // Draw new column
    for (let y = 0; y < height; y++) {
        const normalizedY = 1 - (y / height);
        
        const logMin = Math.log2(minFreq);
        const logMax = Math.log2(maxFreq);
        const freq = Math.pow(2, logMin + normalizedY * (logMax - logMin));
        
        const binIndex = Math.round(freq / binSize);
        
        let value = 0;
        let count = 0;
        for (let b = Math.max(0, binIndex - 1); b <= Math.min(bufferLength - 1, binIndex + 1); b++) {
            value += dataArray[b];
            count++;
        }
        value = count > 0 ? value / count : 0;
        
        const freqBoost = 1 + (1 - normalizedY) * 0.5;
        value = Math.min(255, value * freqBoost);
        
        // Mobile: light on dark | Desktop: dark on light
        const brightness = isMobile ? Math.floor(value * 0.9) : (255 - value);
        
        scopeCtx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
        scopeCtx.fillRect(width - 1, y, 1, 1);
    }
}

// ===========================================
// WAVEFORM OVERLAY (on top of spectrograph)
// ===========================================
function drawWaveformOverlay(width, height, isMobile = false) {
    if (!focusedPathway) return;
    if (!audioContext) return;
    
    const sampleRate = audioContext.sampleRate;
    const fundamental = CONFIG.fundamental || 660;
    
    const ratio = focusedPathway.ratioValue || 1;
    const focusedFreq = fundamental * ratio;
    
    const num = focusedPathway.n || (Array.isArray(focusedPathway.ratio) ? focusedPathway.ratio[0] : 1);
    const denom = focusedPathway.d || (Array.isArray(focusedPathway.ratio) ? focusedPathway.ratio[1] : 1);
    
    const gcd = (a, b) => b ? gcd(b, a % b) : a;
    const lcm = (a, b) => (a * b) / gcd(a, b);
    const cycleRatio = Math.min(lcm(num, denom), 4);
    const basePeriod = sampleRate / fundamental;
    const samplesToShow = Math.max(64, Math.min(Math.floor(basePeriod * cycleRatio), 1024));
    
    // Calculate cycle length in pixels
    const samplesPerCycle = sampleRate / fundamental;
    const pixelsPerCycle = (samplesPerCycle / samplesToShow) * width;
    const numCycles = Math.floor(width / pixelsPerCycle);
    
    // Semi-transparent background for waveform area
    if (isMobile) {
        scopeCtx.fillStyle = 'rgba(17, 17, 17, 0.9)'; // Dark bg for mobile
    } else {
        scopeCtx.fillStyle = 'rgba(255, 255, 255, 0.85)';
    }
    scopeCtx.fillRect(0, 0, width, height);
    
    // Draw cycle markers (subtle vertical lines)
    scopeCtx.strokeStyle = isMobile ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.08)';
    scopeCtx.lineWidth = 1;
    for (let i = 1; i <= numCycles; i++) {
        const x = i * pixelsPerCycle;
        if (x < width) {
            scopeCtx.beginPath();
            scopeCtx.moveTo(x, 0);
            scopeCtx.lineTo(x, height);
            scopeCtx.stroke();
        }
    }
    
    // Center line
    scopeCtx.strokeStyle = isMobile ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)';
    scopeCtx.lineWidth = 1;
    scopeCtx.beginPath();
    scopeCtx.moveTo(0, height / 2);
    scopeCtx.lineTo(width, height / 2);
    scopeCtx.stroke();
    
    // Generate waveform points
    const points = [];
    for (let i = 0; i < samplesToShow; i++) {
        const t = i / sampleRate;
        const wave1 = Math.sin(2 * Math.PI * fundamental * t);
        const wave2 = Math.sin(2 * Math.PI * focusedFreq * t) * 0.7;
        const combined = (wave1 + wave2) / 1.7;
        points.push(combined);
    }
    
    // Draw waveform shadow (subtle depth)
    const sliceWidth = width / points.length;
    const gain = 0.75;
    
    scopeCtx.strokeStyle = isMobile ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
    scopeCtx.lineWidth = isMobile ? 2 : 3;
    scopeCtx.beginPath();
    for (let i = 0; i < points.length; i++) {
        const v = points[i] * gain;
        const y = height / 2 - (v * height / 2.4) + 1;
        const x = i * sliceWidth;
        if (i === 0) scopeCtx.moveTo(x, y);
        else scopeCtx.lineTo(x, y);
    }
    scopeCtx.stroke();
    
    // Draw main waveform
    scopeCtx.strokeStyle = isMobile ? '#fff' : '#000';
    scopeCtx.lineWidth = isMobile ? 1.5 : 1.5;
    scopeCtx.beginPath();
    for (let i = 0; i < points.length; i++) {
        const v = points[i] * gain;
        const y = height / 2 - (v * height / 2.4);
        const x = i * sliceWidth;
        if (i === 0) scopeCtx.moveTo(x, y);
        else scopeCtx.lineTo(x, y);
    }
    scopeCtx.stroke();
    
    // Skip labels on mobile (too small)
    if (isMobile) return;
    
    // Cycle count label (bottom left)
    scopeCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    scopeCtx.font = '7px system-ui';
    scopeCtx.textAlign = 'left';
    const cycleText = cycleRatio === 1 ? '1 cycle' : `${cycleRatio} cycles`;
    scopeCtx.fillText(cycleText, 3, height - 3);
    
    // Ratio label (top right)
    scopeCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    scopeCtx.font = '8px system-ui';
    scopeCtx.textAlign = 'right';
    scopeCtx.fillText(`1/1 + ${num}/${denom}`, width - 3, 9);
}


        // ===========================================
        // CANVAS INTERACTIONS
        // ===========================================
        
        // Desktop click - focus pathway
        spectrumCanvas.addEventListener('click', (e) => {
            if (isPanning) return;
            // Skip on mobile - handled by touch events
            if ('ontouchstart' in window && e.sourceCapabilities?.firesTouchEvents) return;

            const rect = spectrumCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const clicked = findPathwayAtPoint(mouseX, mouseY);

            if (clicked) {
                setFocusedPathway(clicked);
            } else {
                clearFocus();
            }
        });
        
        // ===========================================
        // MOBILE TOUCH - Scrubber Mode with Zoom
        // ===========================================
        let isScrubbing = false;
        let scrubberX = null;
        let scrubberZoom = 1;
        let scrubberCenterFreq = null;
        let lastPippedPathway = null;
        let scrubberAnimationFrame = null;
        
        // Hold-to-focus
        let holdTimer = null;
        let holdPathway = null;
        const HOLD_DURATION = 900; // ms to hold for focus
        
        // Zoom via vertical drag
        let scrubberStartY = null;
        let scrubberCurrentY = null;
        const ZOOM_SENSITIVITY = 0.01; // How much Y movement affects zoom
        const MIN_ZOOM = 1;
        const MAX_ZOOM = 8;
        
        // Target zoom when scrubbing (shows narrower freq range)
        const SCRUB_ZOOM = 3;
        const ZOOM_SPEED = 0.15; // How fast zoom animates
        
        function startScrubbing(touchX, touchY, canvasWidth) {
            // If already focused, any touch clears focus
            if (focusedPathway) {
                clearFocus();
                if (navigator.vibrate) navigator.vibrate(15);
                return;
            }
            
            isScrubbing = true;
            scrubberX = touchX;
            scrubberStartY = touchY;
            scrubberCurrentY = touchY;
            
            // Initialize audio if not already (needed for pips)
            if (!audioContext) {
                initAudio();
            }
            
            // Find pathway at this position and pip it
            const pathway = findPathwayAtX(touchX, canvasWidth);
            
            if (pathway && pathway !== lastPippedPathway) {
                playPip(pathway);
                updatePathwayInfo(pathway);
                if (navigator.vibrate) navigator.vibrate(10);
                lastPippedPathway = pathway;
                hoveredPathway = pathway;
                
                // Start hold timer for focus
                holdPathway = pathway;
                holdTimer = setTimeout(() => {
                    if (holdPathway && holdPathway === pathway) {
                        setFocusedPathway(pathway);
                        if (navigator.vibrate) navigator.vibrate([30, 50, 30]);
                        isScrubbing = false;
                        scrubberX = null;
                    }
                }, HOLD_DURATION);
            }
        }
        
        function updateScrubber(touchX, touchY, canvasWidth) {
            if (!isScrubbing) return;
            
            scrubberX = touchX;
            
            // Vertical drag controls zoom
            if (scrubberStartY !== null) {
                const deltaY = scrubberStartY - touchY; // Drag up = positive = zoom in
                const zoomFactor = 1 + (deltaY * ZOOM_SENSITIVITY);
                scrubberZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomFactor));
                scrubberCurrentY = touchY;
            }
            
            // Find pathway at this position
            const pathway = findPathwayAtX(touchX, canvasWidth);
            if (pathway && pathway !== lastPippedPathway) {
                // Moved to new pathway - cancel hold timer
                if (holdTimer) {
                    clearTimeout(holdTimer);
                    holdTimer = null;
                }
                
                playPip(pathway);
                updatePathwayInfo(pathway);
                if (navigator.vibrate) navigator.vibrate(10);
                lastPippedPathway = pathway;
                hoveredPathway = pathway;
                
                // Start new hold timer
                holdPathway = pathway;
                holdTimer = setTimeout(() => {
                    if (holdPathway && holdPathway === pathway) {
                        setFocusedPathway(pathway);
                        if (navigator.vibrate) navigator.vibrate([30, 50, 30]);
                        isScrubbing = false;
                        scrubberX = null;
                    }
                }, HOLD_DURATION);
            }
        }
        
        function endScrubbing() {
            isScrubbing = false;
            scrubberX = null;
            scrubberStartY = null;
            scrubberCurrentY = null;
            scrubberZoom = 1; // Reset zoom on release
            lastPippedPathway = null;
            
            // Clear hold timer
            if (holdTimer) {
                clearTimeout(holdTimer);
                holdTimer = null;
            }
            holdPathway = null;
        }
        
        function findPathwayAtX(x, canvasWidth) {
            // Use cached bars from last draw - most accurate
            if (cachedBars && cachedBars.length > 0) {
                let closest = null;
                let closestDist = Infinity;
                
                for (const bar of cachedBars) {
                    const dist = Math.abs(bar.x - x);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = bar.pathway;
                    }
                }
                
                // Return if within reasonable distance (15px)
                if (closest && closestDist < 15) {
                    return closest;
                }
            }
            
            // Fallback: calculate from frequency
            if (typeof PATHWAY_DATA === 'undefined' || !PATHWAY_DATA.ALL_PATHWAYS) {
                return null;
            }
            const pathways = PATHWAY_DATA.ALL_PATHWAYS;
            const fundamental = CONFIG.fundamental || 660;
            
            // Convert x to frequency using current zoom
            const minLog = Math.log10(ZOOM.minFreq);
            const maxLog = Math.log10(ZOOM.maxFreq);
            const xRatio = (x - 20) / (canvasWidth - 40);
            const freqLog = minLog + xRatio * (maxLog - minLog);
            const targetFreq = Math.pow(10, freqLog);
            
            let closest = null;
            let closestDist = Infinity;
            
            for (const p of pathways) {
                if ((CONFIG.categoryGains[p.category] ?? 1) === 0) continue;
                if ((CONFIG.subcategoryGains[p.subcategory] ?? 1) === 0) continue;
                
                const pFreq = fundamental * p.ratioValue;
                const dist = Math.abs(Math.log10(pFreq) - Math.log10(targetFreq));
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = p;
                }
            }
            
            if (closest && closestDist < 0.06) {
                return closest;
            }
            return null;
        }
        
        // Touch event handlers for spectrum canvas (MOBILE ONLY)
        spectrumCanvas.addEventListener('touchstart', (e) => {
            const isMobile = window.matchMedia('(max-width: 900px)').matches;
            if (!isMobile) return;
            if (e.touches.length !== 1) return;
            e.preventDefault(); // Prevent scroll
            
            const touch = e.touches[0];
            const rect = spectrumCanvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            const canvasWidth = rect.width;
            
            startScrubbing(touchX, touchY, canvasWidth);
        }, { passive: false });
        
        spectrumCanvas.addEventListener('touchmove', (e) => {
            const isMobile = window.matchMedia('(max-width: 900px)').matches;
            if (!isMobile) return;
            if (!isScrubbing || e.touches.length !== 1) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = spectrumCanvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            const canvasWidth = rect.width;
            
            updateScrubber(touchX, touchY, canvasWidth);
        }, { passive: false });
        
        spectrumCanvas.addEventListener('touchend', (e) => {
            endScrubbing();
        }, { passive: true });
        
        spectrumCanvas.addEventListener('touchcancel', (e) => {
            endScrubbing();
        }, { passive: true });

        spectrumCanvas.addEventListener('dblclick', (e) => {
            if (!isZoomed()) return;
            ZOOM.minFreq = ZOOM.defaultMin;
            ZOOM.maxFreq = ZOOM.defaultMax;
            updateResetButton();
        });

        resetZoomBtn.addEventListener('click', () => {
            ZOOM.minFreq = ZOOM.defaultMin;
            ZOOM.maxFreq = ZOOM.defaultMax;
            updateResetButton();
        });

        spectrumCanvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const rect = spectrumCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const width = rect.width;
            const mouseFreq = xToFreq(mouseX, width);
            
            const zoomIn = e.deltaY < 0;
            const factor = zoomIn ? (1 - ZOOM.zoomSpeed) : (1 + ZOOM.zoomSpeed);
            
            const minLog = Math.log10(ZOOM.minFreq);
            const maxLog = Math.log10(ZOOM.maxFreq);
            const mouseLog = Math.log10(mouseFreq);
            
            const leftDist = mouseLog - minLog;
            const rightDist = maxLog - mouseLog;
            
            const newMinLog = mouseLog - leftDist * factor;
            const newMaxLog = mouseLog + rightDist * factor;
            
            let newMin = Math.pow(10, newMinLog);
            let newMax = Math.pow(10, newMaxLog);
            
            newMin = Math.max(20, newMin);
            newMax = Math.min(20000, newMax);
            
            if (newMax - newMin < ZOOM.minRange) return;
            
            if (newMin < ZOOM.defaultMin) newMin = ZOOM.defaultMin;
            if (newMax > ZOOM.defaultMax) newMax = ZOOM.defaultMax;
            
            ZOOM.minFreq = newMin;
            ZOOM.maxFreq = newMax;
            updateResetButton();
        }, { passive: false });

        spectrumCanvas.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            
            const rect = spectrumCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const clickedPathway = findPathwayAtPoint(mouseX, mouseY);
            
            if (!clickedPathway && isZoomed()) {
                isPanning = true;
                panStartX = e.clientX;
                panStartMinFreq = ZOOM.minFreq;
                panStartMaxFreq = ZOOM.maxFreq;
                spectrumCanvas.style.cursor = 'grabbing';
            }
        });

        spectrumCanvas.addEventListener('mousemove', (e) => {
            const rect = spectrumCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const width = rect.width;
            
            if (isPanning) {
                const deltaX = e.clientX - panStartX;
                const panRatio = deltaX / (width - 60);
                
                const startMinLog = Math.log10(panStartMinFreq);
                const startMaxLog = Math.log10(panStartMaxFreq);
                const rangeLog = startMaxLog - startMinLog;
                const shiftLog = -panRatio * rangeLog;
                
                let newMinLog = startMinLog + shiftLog;
                let newMaxLog = startMaxLog + shiftLog;
                
                if (newMinLog < Math.log10(ZOOM.defaultMin)) {
                    newMinLog = Math.log10(ZOOM.defaultMin);
                    newMaxLog = newMinLog + rangeLog;
                }
                if (newMaxLog > Math.log10(ZOOM.defaultMax)) {
                    newMaxLog = Math.log10(ZOOM.defaultMax);
                    newMinLog = newMaxLog - rangeLog;
                }
                
                ZOOM.minFreq = Math.pow(10, newMinLog);
                ZOOM.maxFreq = Math.pow(10, newMaxLog);
                return;
            }
            
            if (!isPlaying) {
                hoveredPathway = null;
                spectrumCanvas.style.cursor = isZoomed() ? 'grab' : 'default';
                return;
            }
            
            const closest = findPathwayAtPoint(mouseX, mouseY);
            
            if (closest !== hoveredPathway) {
                hoveredPathway = closest;
                
                if (closest) {
                    if (Date.now() - lastPipTime > PIP_COOLDOWN) {
                        playPip(closest);
                        lastPipTime = Date.now();
                    }
                    
                    if (!focusedPathway) {
                        updatePathwayInfo(closest);
                    }
                }
            }
            
            spectrumCanvas.style.cursor = closest ? 'pointer' : (isZoomed() ? 'grab' : 'default');
        });

        window.addEventListener('mouseup', () => {
            if (isPanning) {
                isPanning = false;
                spectrumCanvas.style.cursor = isZoomed() ? 'grab' : 'default';
            }
        });

        spectrumCanvas.addEventListener('mouseleave', () => {
            hoveredPathway = null;
            if (isPanning) isPanning = false;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                clearFocus();
            }
        });

        // ===========================================
        // MODE TOGGLE HANDLERS
        // ===========================================
        let currentMode = 'composed';
        
        document.querySelectorAll('#modeToggle .mode-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                const newMode = btn.dataset.mode;
                if (newMode === currentMode) return;
                
                // Update toggle UI immediately
                document.querySelectorAll('#modeToggle .mode-btn').forEach(b => {
                    b.classList.toggle('active', b.dataset.mode === newMode);
                });
                
                // Remember current state to restore after transition
                const hadFocus = focusedPathway;
                const hadFinding = activeFinding;
                const hadFindingPathways = hadFinding ? [...findingPathways] : null;
                
                // Clear pathway focus but NOT key findings (they persist)
                if (focusedPathway) {
                    focusedPathway = null;
                    if (workletNode) {
                        workletNode.port.postMessage({ type: 'setFocus', data: { id: null } });
                    }
                }
                
                // Quick fade out (reverb tail carries through)
                if (workletNode && isPlaying) {
                    workletNode.port.postMessage({
                        type: 'fadeOut',
                        data: { duration: 0.2 }
                    });
                    await new Promise(resolve => setTimeout(resolve, 220));
                }
                
                // Switch mode
                currentMode = newMode;
                CONFIG.currentMode = newMode;
                
                // Tell worklet about mode change (affects granular rain movement)
                if (workletNode) {
                    workletNode.port.postMessage({
                        type: 'setComposedMode',
                        data: { enabled: newMode === 'composed' }
                    });
                }
                
                // Update visualization background
                const vizContainer = document.getElementById('vizContainer');
                vizContainer.classList.toggle('dark-mode', newMode === 'consonance');
                
                // Brief visual flash to indicate transition
                vizContainer.classList.add('mode-transition');
                setTimeout(() => vizContainer.classList.remove('mode-transition'), 300);
                
                // Switch pathway data
                if (typeof PATHWAY_DATA !== 'undefined' && typeof PATHWAY_DATA.switchMode === 'function') {
                    const pathways = PATHWAY_DATA.switchMode(newMode);
                    
                    // Update nav button subtitle
                    const navSub = document.getElementById('healthyNavSub');
                    if (navSub) navSub.textContent = 'Curated Pathways';
                    
                    // Rebuild MS_AFFECTED_PATHWAYS with mode filter
                    if (msMode && typeof PATHWAY_DATA.MS_COMPARISON_DATA !== 'undefined') {
                        MS_AFFECTED_PATHWAYS.clear();
                        MS_DEPLETED_PATHWAYS.clear();
                        MS_ELEVATED_PATHWAYS.clear();
                        
                        const msData = PATHWAY_DATA.MS_COMPARISON_DATA;
                        for (const id of Object.keys(msData)) {
                            const info = msData[id];
                            // Skip if pathway has mode restriction and current mode doesn't match
                            if (info.modes && !info.modes.includes(newMode)) {
                                continue;
                            }
                            MS_AFFECTED_PATHWAYS.add(id);
                            if (info.enrichedIn === 'healthy') {
                                MS_DEPLETED_PATHWAYS.add(id);
                            } else {
                                MS_ELEVATED_PATHWAYS.add(id);
                            }
                        }
                        console.log(`MS mode switch: ${MS_AFFECTED_PATHWAYS.size} affected pathways for ${newMode}`);
                    }
                    
                    // Reinitialize audio with new mappings
                    if (workletNode && isPlaying) {
                        workletNode.port.postMessage({
                            type: 'init',
                            data: {
                                pathways: pathways.map(p => ({
                                    id: p.id,
                                    n: p.n,
                                    d: p.d,
                                    ratio: p.ratioValue,
                                    amplitude: p.amplitude || p.prevalence,
                                    category: p.category,
                                    subcategory: p.subcategory
                                }))
                            }
                        });
                        
                        // Re-send MS data if in MS mode
                        if (msMode && typeof PATHWAY_DATA.MS_COMPARISON_DATA !== 'undefined') {
                            workletNode.port.postMessage({
                                type: 'setMSMode',
                                data: { enabled: true, msData: PATHWAY_DATA.MS_COMPARISON_DATA }
                            });
                        }
                        
                        // Re-trigger key finding with NEW mode's pathways
                        if (hadFinding) {
                            // Re-call focusKeyFinding to get correct pathways for new mode
                            focusKeyFinding(hadFinding);
                        }
                        
                        // Quick fade in
                        workletNode.port.postMessage({
                            type: 'fadeIn',
                            data: { duration: 0.3 }
                        });
                    }
                    
                    // Restore pathway focus if it exists in new mode
                    if (hadFocus) {
                        const newPathway = pathways.find(p => p.id === hadFocus.id);
                        if (newPathway) {
                            setTimeout(() => setFocusedPathway(newPathway), 100);
                        }
                    }
                    
                    // Update subcategory UI
                    updateSubcategoryUI(activeCategory);
                    
                    console.log(`Mode switched to: ${newMode} (${pathways.length} pathways)`);
                }
            });
        });

        // ===========================================
        // INITIALIZATION
        // ===========================================
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();
        
        updateSubcategoryUI('energy');
        
        if (typeof PATHWAY_DATA !== 'undefined' && PATHWAY_DATA.ALL_PATHWAYS.length > 0) {
            updatePathwayInfo(PATHWAY_DATA.ALL_PATHWAYS[0]);
            
            const maxRatio = Math.max(...PATHWAY_DATA.ALL_PATHWAYS.map(p => p.ratioValue));
            const maxPossibleFreq = 600 * maxRatio * 1.01;
            ZOOM.defaultMax = Math.ceil(maxPossibleFreq / 1000) * 1000;
            ZOOM.maxFreq = ZOOM.defaultMax;
            
            console.log(`Frequency range: ${ZOOM.defaultMin} - ${ZOOM.defaultMax} Hz (max ratio: ${maxRatio.toFixed(2)})`);
        }
        
        drawSpectrum();
        drawOscilloscope();
        loadPathwaySummaries();
        
        // ===========================================
        // MOBILE: Sync controls between desktop and mobile
        // ===========================================
        
        // Sync mobile volume slider with desktop
        const mobileVolumeSlider = document.querySelector('.mobile-volume-slider');
        const mobileVolumeValue = document.querySelector('.mobile-volume-value');
        const desktopVolumeSlider = document.getElementById('volumeSlider');
        const desktopVolumeValue = document.getElementById('volumeValue');
        
        if (mobileVolumeSlider && desktopVolumeSlider) {
            mobileVolumeSlider.addEventListener('input', function() {
                desktopVolumeSlider.value = this.value;
                desktopVolumeSlider.dispatchEvent(new Event('input'));
                mobileVolumeValue.textContent = this.value + '%';
            });
            
            desktopVolumeSlider.addEventListener('input', function() {
                mobileVolumeSlider.value = this.value;
                mobileVolumeValue.textContent = this.value + '%';
            });
        }
        
        // Sync mobile fundamental slider
        const mobileFundSlider = document.querySelector('.mobile-fundamental-slider');
        const mobileFundValue = document.querySelector('.mobile-fundamental-value');
        const desktopFundSlider = document.getElementById('fundamentalSlider');
        const desktopFundValue = document.getElementById('fundamentalValue');
        
        if (mobileFundSlider && desktopFundSlider) {
            mobileFundSlider.addEventListener('input', function() {
                desktopFundSlider.value = this.value;
                desktopFundSlider.dispatchEvent(new Event('input'));
                mobileFundValue.textContent = this.value + ' Hz';
            });
            
            desktopFundSlider.addEventListener('input', function() {
                mobileFundSlider.value = this.value;
                mobileFundValue.textContent = this.value + ' Hz';
            });
        }
        
        // Sync mobile category sliders
        document.querySelectorAll('.mobile-cat-slider').forEach(mobileSlider => {
            const cat = mobileSlider.dataset.category;
            const desktopSlider = document.querySelector(`#categoryFaders input[data-category="${cat}"]`);
            
            if (desktopSlider) {
                mobileSlider.addEventListener('input', function() {
                    desktopSlider.value = this.value;
                    desktopSlider.dispatchEvent(new Event('input'));
                });
                
                desktopSlider.addEventListener('input', function() {
                    mobileSlider.value = this.value;
                });
            }
        });
        
        // Mobile category buttons - switch subcategory view
        document.querySelectorAll('.mobile-category-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const cat = this.dataset.category;
                mobileActiveCategory = cat;
                updateMobileSubcategoryUI(cat);
            });
        });
        
        // Track mobile active category
        let mobileActiveCategory = 'energy';
        const MOBILE_CATEGORY_ORDER = ['energy', 'biosynthesis', 'degradation', 'salvage', 'other'];
        
        // Populate mobile subcategories for a category
        function updateMobileSubcategoryUI(category) {
            const container = document.getElementById('mobileSubcategoryFaders');
            const indicator = document.getElementById('mobileSubcatIndicator');
            const label = document.getElementById('mobileSubcatLabel');
            
            if (!container) return;
            
            const catColors = {
                energy: '#22c55e',
                biosynthesis: '#3b82f6',
                degradation: '#f59e0b',
                salvage: '#ec4899',
                other: '#6b7280'
            };
            
            const catNames = {
                energy: 'Energy',
                biosynthesis: 'Biosynthesis',
                degradation: 'Degradation',
                salvage: 'Salvage',
                other: 'Other'
            };
            
            indicator.style.background = catColors[category] || '#888';
            label.textContent = catNames[category] || category;
            
            // Use SUBCATEGORY_MAP for ordering (same as desktop)
            const subcats = SUBCATEGORY_MAP[category] || [];
            
            container.innerHTML = '';
            
            if (subcats.length === 0) {
                container.innerHTML = '<div style="font-size:0.6rem;color:#888;padding:8px;">No subcategories</div>';
                return;
            }
            
            subcats.forEach(sub => {
                const fader = document.createElement('div');
                fader.className = 'subcategory-fader';
                fader.dataset.subcategory = sub.id;
                fader.dataset.category = category;
                fader.innerHTML = `
                    <button class="subcat-btn mobile-subcat-btn" data-subcat="${sub.id}" data-category="${category}">${sub.label}</button>
                    <input type="range" class="mobile-subcat-slider" data-subcat="${sub.id}" data-category="${category}" min="0" max="100" value="${Math.round((CONFIG.subcategoryGains[sub.id] ?? 1) * 100)}">
                `;
                container.appendChild(fader);
            });
            
            // Add event listeners for mobile subcategory controls
            container.querySelectorAll('.mobile-subcat-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const subcat = this.dataset.subcat;
                    const cat = this.dataset.category;
                    // Call toggleSubcategoryCycle directly with mobile button
                    toggleSubcategoryCycle(subcat, cat, this);
                });
            });
            
            container.querySelectorAll('.mobile-subcat-slider').forEach(slider => {
                slider.addEventListener('input', function() {
                    const subcat = this.dataset.subcat;
                    setSubcategoryGain(subcat, parseInt(this.value) / 100);
                });
            });
        }
        
        // Mobile subcategory navigation (right arrow only - cycles through)
        document.getElementById('mobileSubcatNext')?.addEventListener('click', () => {
            const idx = MOBILE_CATEGORY_ORDER.indexOf(mobileActiveCategory);
            const newIdx = idx >= MOBILE_CATEGORY_ORDER.length - 1 ? 0 : idx + 1;
            mobileActiveCategory = MOBILE_CATEGORY_ORDER[newIdx];
            updateMobileSubcategoryUI(mobileActiveCategory);
        });
        
        // Mobile solo button
        document.getElementById('mobileSoloBtn')?.addEventListener('click', function() {
            const desktopSolo = document.getElementById('soloAllBtn');
            if (desktopSolo) desktopSolo.click();
            this.classList.toggle('active');
        });
        
        // Mobile stop button
        document.getElementById('mobileStopBtn')?.addEventListener('click', function() {
            stopAllSequences();
            this.classList.remove('has-active');
            // Also clear cycling state from mobile buttons
            document.querySelectorAll('.mobile-subcat-btn.cycling').forEach(btn => {
                btn.classList.remove('cycling');
            });
        });
        
        // Initialize mobile subcategories with Energy
        updateMobileSubcategoryUI('energy');
        
        // Sync mobile nav buttons with desktop
        document.querySelectorAll('.mobile-nav-btn').forEach(mobileBtn => {
            mobileBtn.addEventListener('click', function() {
                const view = this.dataset.view;
                const desktopBtn = document.querySelector(`.sidebar .nav-btn[data-view="${view}"]`);
                if (desktopBtn) {
                    desktopBtn.click();
                }
                // Update mobile button states
                document.querySelectorAll('.mobile-nav-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
            });
        });
        
        // Sync mobile finding buttons - call focusKeyFinding directly
        document.querySelectorAll('.mobile-finding-btn').forEach(mobileBtn => {
            console.log('Attaching handler to mobile finding btn:', mobileBtn.dataset.finding);
            mobileBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                console.log('Mobile finding clicked!', this.dataset.finding, 'disabled:', this.disabled);
                
                if (this.disabled) {
                    console.log('Button is disabled, returning');
                    return;
                }
                
                const findingId = this.dataset.finding;
                console.log('Calling focusKeyFinding with:', findingId);
                console.log('MS_KEY_FINDINGS available:', !!window.MS_KEY_FINDINGS);
                
                focusKeyFinding(findingId);
            });
        });
        
        console.log('Mobile finding buttons attached:', document.querySelectorAll('.mobile-finding-btn').length);
        
        // When MS mode is enabled/disabled, sync mobile finding buttons
        const msCompareBtn = document.getElementById('msCompareBtn');
        if (msCompareBtn) {
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'class') {
                        const isActive = msCompareBtn.classList.contains('active');
                        document.querySelectorAll('.mobile-finding-btn').forEach(btn => {
                            if (isActive) {
                                btn.classList.remove('disabled');
                                btn.disabled = false;
                            } else {
                                btn.classList.add('disabled');
                                btn.disabled = true;
                            }
                        });
                        // Update mobile MS button
                        const mobileMsBtn = document.querySelector('.mobile-nav-btn[data-view="ms"]');
                        if (mobileMsBtn) {
                            if (isActive) {
                                mobileMsBtn.classList.add('active');
                                document.querySelector('.mobile-nav-btn[data-view="healthy"]')?.classList.remove('active');
                            }
                        }
                    }
                });
            });
            observer.observe(msCompareBtn, { attributes: true });
        }
        
        console.log('Metabolic Harmony v5.3 - Mobile Ready');
        if (typeof PATHWAY_DATA !== 'undefined') console.log('Loaded ' + PATHWAY_DATA.ALL_PATHWAYS.length + ' pathways');
        if (Object.keys(PATHWAY_SUMMARIES).length > 0) console.log('Loaded ' + Object.keys(PATHWAY_SUMMARIES).length + ' pathway summaries');
    </script>
</body>
</html>
